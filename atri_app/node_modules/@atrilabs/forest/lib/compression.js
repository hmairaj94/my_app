"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compressEvents = void 0;
var forest_1 = require("./forest");
/**
 * It implements a tree agnostic compression algorithm.
 * All patch events are merged. Only last link event is kept.
 * Only last unlink event is kept. A node is dropped if delete is emitted.
 */
function compressEvents(events, forestDef) {
    if (forestDef.trees.length === 0) {
        throw Error("Need atleas one tree in ForestDef");
    }
    var forest = (0, forest_1.createForest)(forestDef);
    forest.handleEvents({
        name: "COMPRESSION",
        events: events,
        meta: { agent: "server-sent" },
    });
    var treeIds = forestDef.trees.map(function (treeDef) {
        return treeDef.id;
    });
    var rootTreeId = treeIds[0];
    // root tree components
    var rootTree = forest.tree(rootTreeId);
    var rootTreeNodeMap = rootTree.nodes;
    var rootTreeNodeIds = Object.keys(rootTreeNodeMap);
    // process non root trees first
    var nonRootTreeEvents = treeIds
        .filter(function (treeId) { return treeId !== rootTreeId; })
        .map(function (treeId) {
        var tree = forest.tree(treeId);
        var nodeMap = tree.nodes;
        var linkRefIds = Object.keys(tree.links);
        // keep only those nodes that are linked to root tree
        var nodeIds = linkRefIds
            .filter(function (refId) {
            return refId in rootTreeNodeMap;
        })
            .map(function (refId) {
            return tree.links[refId].childId;
        });
        var reverseLinkMap = {};
        linkRefIds.forEach(function (linkRefId) {
            reverseLinkMap[tree.links[linkRefId].childId] = linkRefId;
        });
        return nodeIds.map(function (nodeId) {
            var node = nodeMap[nodeId];
            return [
                {
                    type: "CREATE$$".concat(treeId),
                    id: nodeId,
                    meta: node.meta,
                    state: node.state,
                },
                {
                    type: "LINK$$".concat(treeId),
                    childId: nodeId,
                    refId: reverseLinkMap[nodeId],
                },
            ];
        });
    })
        .flat()
        .flat();
    var rootTreeEvents = rootTreeNodeIds.map(function (nodeId) {
        var node = rootTreeNodeMap[nodeId];
        return {
            type: "CREATE$$".concat(rootTreeId),
            id: nodeId,
            meta: node.meta,
            state: node.state,
        };
    });
    return __spreadArray(__spreadArray([], nonRootTreeEvents, true), rootTreeEvents, true);
}
exports.compressEvents = compressEvents;
//# sourceMappingURL=compression.js.map