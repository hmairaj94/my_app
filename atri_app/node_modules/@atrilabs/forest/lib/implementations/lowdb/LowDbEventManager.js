"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var lowdb_1 = __importDefault(require("lowdb"));
var FileSync_1 = __importDefault(require("lowdb/adapters/FileSync"));
var path_1 = __importDefault(require("path"));
var fs_1 = __importDefault(require("fs"));
var types_1 = require("./types");
function metaFile(dbDir) {
    return path_1.default.resolve(dbDir, "meta.json");
}
function pagesFile(dbDir) {
    return path_1.default.resolve(dbDir, "pages.json");
}
function aliasFile(dbDir) {
    return path_1.default.resolve(dbDir, "alias.json");
}
function eventFile(dbDir, pageId) {
    return path_1.default.resolve(dbDir, "events", pageId, "events.json");
}
/**
 * <rootDir>
 * - meta.json (the schema of this file is decided by the server-client using this implementation)
 * - pages.json (contains page-id and it's name)
 * - alias.json (contains alias and it's count)
 * - events/ (contains one file for each page)
 *    - xxx-pageid-events.json
 *
 * Initial state of these files:
 * meta.json              <- empty
 * pages.json             <- {}
 * alias.json             <- {}
 * xxx-pageid-events.json <- []
 * @param dbDir root directory where all the files will be saved
 * @returns true if file layout is valid
 */
function checkFileLayout(dbDir) {
    var hasError = false;
    var report = {};
    if (!fs_1.default.existsSync(metaFile(dbDir))) {
        report.meta = types_1.LayoutErrorType.missing;
    }
    if (!fs_1.default.existsSync(aliasFile(dbDir))) {
        report.alias = types_1.LayoutErrorType.missing;
    }
    else {
        var data = fs_1.default.readFileSync(aliasFile(dbDir)).toString();
        if (data.match(/^\s\s*\s$/)) {
            report.alias = types_1.LayoutErrorType.empty;
        }
    }
    if (!fs_1.default.existsSync(pagesFile(dbDir))) {
        report.pages = types_1.LayoutErrorType.missing;
    }
    else {
        var data = fs_1.default.readFileSync(pagesFile(dbDir)).toString();
        if (data.match(/^\s\s*\s$/)) {
            report.pages = types_1.LayoutErrorType.empty;
        }
        else {
            try {
                var json = JSON.parse(fs_1.default.readFileSync(pagesFile(dbDir)).toString());
                if (typeof json !== "object")
                    report.pages = types_1.LayoutErrorType.invalidData;
            }
            catch (_a) {
                report.pages = types_1.LayoutErrorType.invalidData;
            }
        }
    }
    // check for event files only if there are no errors for pages
    if (report.pages === undefined) {
        var json = JSON.parse(fs_1.default.readFileSync(pagesFile(dbDir)).toString());
        var pageIds = Object.keys(json);
        pageIds.forEach(function (pageId) {
            if (!fs_1.default.existsSync(eventFile(dbDir, pageId))) {
                if (report.events === undefined) {
                    report.events = {};
                }
                report.events[pageId] = types_1.LayoutErrorType.missing;
            }
            else {
                var data = fs_1.default.readFileSync(eventFile(dbDir, pageId)).toString();
                if (data.match(/^\s\s*\s$/)) {
                    if (report.events === undefined) {
                        report.events = {};
                    }
                    report.events[pageId] = types_1.LayoutErrorType.empty;
                }
                else {
                    try {
                        var json_1 = JSON.parse(data);
                        if (typeof json_1 !== "object" && !Array.isArray(json_1)) {
                            if (report.events === undefined) {
                                report.events = {};
                            }
                            report.events[pageId] = types_1.LayoutErrorType.invalidData;
                        }
                    }
                    catch (_a) {
                        if (report.events === undefined) {
                            report.events = {};
                        }
                        report.events[pageId] = types_1.LayoutErrorType.invalidData;
                    }
                }
            }
        });
    }
    return { hasError: hasError, report: report };
}
/**
 * It fixes the dbDir in following ways:
 * - Create any missing file with it's initial value
 * - It also ensures that all pages mentioned in pages.json have a events file in events directory
 * @param dbDir root directory where all the files will be saved
 */
function fixFileLayout(dbDir, report) {
    var hasUnfixedErrors = false;
    var reportAfterFixes = {};
    if (report.meta) {
        if (report.meta.valueOf() === types_1.LayoutErrorType.missing.valueOf())
            fs_1.default.writeFileSync(metaFile(dbDir), "");
        else {
            hasUnfixedErrors = true;
            reportAfterFixes.meta = report.meta;
        }
    }
    if (report.alias) {
        if (report.alias.valueOf() === types_1.LayoutErrorType.missing.valueOf())
            fs_1.default.writeFileSync(aliasFile(dbDir), "{}");
        else {
            hasUnfixedErrors = true;
            reportAfterFixes.alias = report.alias;
        }
    }
    if (report.pages) {
        if (report.pages.valueOf() === types_1.LayoutErrorType.missing.valueOf())
            fs_1.default.writeFileSync(pagesFile(dbDir), "{}");
        else {
            hasUnfixedErrors = true;
            reportAfterFixes.pages = report.pages;
        }
    }
    if (report.events) {
        var pageIds = Object.keys(report.events);
        pageIds.forEach(function (pageId) {
            var error = report.events[pageId];
            if (error.valueOf() === types_1.LayoutErrorType.missing.valueOf()) {
                fs_1.default.writeFileSync(eventFile(dbDir, pageId), "[]");
            }
            else {
                hasUnfixedErrors = true;
                if (reportAfterFixes.events === undefined) {
                    reportAfterFixes.events = {};
                }
                reportAfterFixes.events[pageId] = error;
            }
        });
    }
    return { hasUnfixedErrors: hasUnfixedErrors, reportAfterFixes: reportAfterFixes };
}
var openDbs = {
    events: {},
};
function getMetaDb(dbDir, mode) {
    var file = metaFile(dbDir);
    if (openDbs.meta) {
        if (mode === "readonly") {
            openDbs.meta.setState(JSON.parse(fs_1.default.readFileSync(file).toString()));
        }
        return openDbs.meta;
    }
    var metaDb = (0, lowdb_1.default)(new FileSync_1.default(file));
    metaDb.read();
    openDbs.meta = metaDb;
    return metaDb;
}
function getAliasDb(dbDir, mode) {
    var file = aliasFile(dbDir);
    if (openDbs.alias) {
        if (mode === "readonly") {
            openDbs.alias.setState(JSON.parse(fs_1.default.readFileSync(file).toString()));
        }
        return openDbs.alias;
    }
    var aliasDb = (0, lowdb_1.default)(new FileSync_1.default(file));
    aliasDb.read();
    openDbs.alias = aliasDb;
    return aliasDb;
}
function getPagesDb(dbDir, mode) {
    var file = pagesFile(dbDir);
    if (openDbs.pages) {
        if (mode === "readonly") {
            openDbs.pages.setState(JSON.parse(fs_1.default.readFileSync(file).toString()));
        }
        return openDbs.pages;
    }
    var pagesDb = (0, lowdb_1.default)(new FileSync_1.default(file));
    pagesDb.read();
    openDbs.pages = pagesDb;
    return pagesDb;
}
function getEventsDb(dbDir, pageId, mode) {
    var eventsFile = eventFile(dbDir, pageId);
    if (openDbs.events[pageId]) {
        if (mode === "readonly") {
            openDbs.events[pageId].setState(JSON.parse(fs_1.default.readFileSync(eventsFile).toString()));
        }
        return openDbs.events[pageId];
    }
    var eventsDb = (0, lowdb_1.default)(new FileSync_1.default(eventsFile));
    eventsDb.read();
    // If events file is empty, lowdb writes {} by default. We override it for events file.
    var initState = eventsDb.getState();
    if (JSON.stringify(initState) === "{}") {
        eventsDb.setState([]);
        eventsDb.write();
    }
    openDbs.events[pageId] = eventsDb;
    return eventsDb;
}
function deleteEventsDb(dbDir, pageId) {
    if (openDbs.events[pageId]) {
        delete openDbs.events[pageId];
        var eventsFilename = eventFile(dbDir, pageId);
        if (fs_1.default.existsSync(eventsFilename))
            fs_1.default.rmSync(path_1.default.dirname(eventsFilename), { force: true });
    }
}
function createEventsFile(filePath, content) {
    if (!fs_1.default.existsSync(filePath)) {
        if (!fs_1.default.existsSync(path_1.default.dirname(filePath))) {
            fs_1.default.mkdirSync(path_1.default.dirname(filePath), { recursive: true });
        }
        fs_1.default.writeFileSync(filePath, content);
    }
}
function createLowDbEventManager(options) {
    var dbDir = options.dbDir;
    // create files with default content if file doesn't exists already
    var _a = checkFileLayout(dbDir), hasError = _a.hasError, report = _a.report;
    if (hasError) {
        var _b = fixFileLayout(dbDir, report), hasUnfixedErrors = _b.hasUnfixedErrors, reportAfterFixes = _b.reportAfterFixes;
        if (hasUnfixedErrors) {
            console.log("Found errors in lowdb that cannot be fixed automatically\n", JSON.stringify(reportAfterFixes, null, 2));
            process.exit(-1);
        }
    }
    var metaDb = getMetaDb(dbDir, options.mode);
    var pagesDb = getPagesDb(dbDir, options.mode);
    var aliasDb = getAliasDb(dbDir, options.mode);
    function meta() {
        return metaDb.getState();
    }
    function updateMeta(data) {
        metaDb.setState(data);
    }
    function pages() {
        return pagesDb.getState();
    }
    function createPage(id, name, route) {
        // do nothing if a page with id Page["id"] already exists
        if (pagesDb.getState()[id]) {
            console.log("Error: Page with id ".concat(id, " already exists. Cannot create a new page."));
            return;
        }
        pagesDb.getState()[id] = { name: name, route: route };
        var eventsFile = eventFile(dbDir, id);
        createEventsFile(eventsFile, "[]");
    }
    function renamePage(id, name) {
        if (!pagesDb.getState()[id]) {
            console.log("Error: Page with id ".concat(id, " does not exist. Cannot rename."));
            return;
        }
        pagesDb.getState()[id]["name"] = name;
    }
    function changeRoute(id, route) {
        if (!pagesDb.getState()[id]) {
            console.log("Error: Page with id ".concat(id, " does not exist. Cannot change route."));
            return;
        }
        pagesDb.getState()[id]["route"] = route;
    }
    function deletePage(id) {
        var pages = pagesDb.getState();
        delete pages[id];
        pagesDb.setState(pages);
        deleteEventsDb(dbDir, id);
    }
    function storeEvent(pageId, event) {
        var eventsDb = getEventsDb(dbDir, pageId, options.mode);
        eventsDb.getState().push(event);
    }
    function fetchEvents(pageId) {
        // open pages db if not already open
        var eventsDb = getEventsDb(dbDir, pageId, options.mode);
        return JSON.parse(JSON.stringify(eventsDb.getState()));
    }
    function writeBackCompressedEvents(pageId, events) {
        var eventsDb = getEventsDb(dbDir, pageId, options.mode);
        eventsDb.setState(events);
    }
    function incrementAlias(prefix) {
        if (aliasDb.getState()[prefix] !== undefined) {
            var oldValue = aliasDb.getState()[prefix];
            var newValue = oldValue + 1;
            aliasDb.getState()[prefix] = newValue;
            return newValue;
        }
        aliasDb.getState()[prefix] = 1;
        return aliasDb.getState()[prefix];
    }
    function createWriteProxy(fn) {
        var proxyFn = new Proxy(fn, {
            apply: function (target, _thisArg, args) {
                var returnValue = fn.apply(void 0, args);
                // TODO: maybe we should debounce write operation and move it inside a promise as well
                if ([updateMeta].includes(target)) {
                    metaDb.write();
                }
                if ([createPage, renamePage, changeRoute, deletePage].includes(target)) {
                    pagesDb.write();
                }
                if ([incrementAlias].includes(target)) {
                    aliasDb.write();
                }
                if ([storeEvent].includes(target)) {
                    var eventsDb = getEventsDb(dbDir, args[0], options.mode);
                    eventsDb.write();
                }
                return returnValue;
            },
        });
        return proxyFn;
    }
    var api = {
        meta: meta,
        updateMeta: updateMeta,
        pages: pages,
        createPage: createPage,
        renamePage: renamePage,
        changeRoute: changeRoute,
        deletePage: deletePage,
        storeEvent: storeEvent,
        fetchEvents: fetchEvents,
        writeBackCompressedEvents: writeBackCompressedEvents,
        incrementAlias: incrementAlias,
    };
    var apiProxy = __assign({}, api);
    Object.keys(apiProxy).forEach(function (key) {
        apiProxy[key] = createWriteProxy(apiProxy[key]);
    });
    return apiProxy;
}
exports.default = createLowDbEventManager;
//# sourceMappingURL=LowDbEventManager.js.map