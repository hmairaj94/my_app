"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createForest = void 0;
var lodash_1 = require("lodash");
var tree_1 = require("./tree");
function mergeStateCustomizer(obj, src) {
    // replace array instead of default merge
    if (Array.isArray(obj)) {
        return src;
    }
}
function createForest(def) {
    var treeDefs = def.trees;
    if (treeDefs.length === 0) {
        throw Error("Atleast one tree definition is required");
    }
    var rootDef = def.trees[0];
    // create a map for easily accessing a tree when an event arrives
    var defaultFnMap = {};
    treeDefs.forEach(function (def) {
        var id = def.modulePath;
        defaultFnMap[id] = def.defFn();
    });
    // create an empty map of trees to be filled once API for forest is ready below
    var treeMap = {};
    var forestUpdateSubscribers = [];
    /**
     * EXPOSE API
     */
    // get a tree by it's name
    function tree(treeId) {
        return treeMap[treeId];
    }
    // record all link events in the forest to process unlink
    // called as a result of deleting something in root tree
    var linkEvents = {};
    function createReverseMap(nodes) {
        var reverseMap = {};
        Object.keys(nodes).forEach(function (nodeId) {
            var node = nodes[nodeId];
            var parentId = node.state.parent.id;
            if (reverseMap[parentId]) {
                reverseMap[parentId].push(nodeId);
            }
            else {
                reverseMap[parentId] = [nodeId];
            }
        });
        return reverseMap;
    }
    function handleEvent(name, event, meta) {
        var _a, _b, _c, _d, _e;
        if (event.type.startsWith("CREATE")) {
            var createEvent_1 = event;
            var treeId_1 = createEvent_1.type.slice("CREATE$$".length);
            if (defaultFnMap[treeId_1].validateCreate(createEvent_1)) {
                treeMap[treeId_1].nodes[createEvent_1.id] = {
                    id: createEvent_1.id,
                    meta: createEvent_1.meta,
                    state: createEvent_1.state,
                };
                forestUpdateSubscribers.forEach(function (cb) {
                    cb({
                        type: "wire",
                        id: createEvent_1.id,
                        parentId: createEvent_1.state.parent.id,
                        treeId: treeId_1,
                    }, { name: name, meta: meta });
                });
            }
        }
        if (event.type.startsWith("PATCH")) {
            var patchEvent_1 = event;
            var treeId_2 = patchEvent_1.type.slice("PATCH$$".length);
            if (defaultFnMap[treeId_2].validatePatch(patchEvent_1)) {
                var stringified = JSON.stringify(tree(treeId_2).nodes[patchEvent_1.id]["state"]);
                var newState = JSON.parse(stringified);
                var oldState_1 = JSON.parse(stringified);
                // patch parent
                if (patchEvent_1.slice && patchEvent_1.slice.parent) {
                    if (patchEvent_1.slice.parent.id &&
                        patchEvent_1.slice.parent.index !== undefined &&
                        !isNaN(patchEvent_1.slice.parent.index)) {
                        var oldParentId_1 = (_b = (_a = tree(treeId_2)) === null || _a === void 0 ? void 0 : _a.nodes[patchEvent_1.id]) === null || _b === void 0 ? void 0 : _b.state.parent.id;
                        var oldIndex_1 = (_d = (_c = tree(treeId_2)) === null || _c === void 0 ? void 0 : _c.nodes[patchEvent_1.id]) === null || _d === void 0 ? void 0 : _d.state.parent.index;
                        if (oldParentId_1 !== undefined && oldIndex_1 !== undefined) {
                            tree(treeId_2).nodes[patchEvent_1.id]["state"] = (0, lodash_1.mergeWith)(newState, JSON.parse(JSON.stringify(patchEvent_1.slice)), mergeStateCustomizer);
                            forestUpdateSubscribers.forEach(function (cb) {
                                cb({
                                    type: "rewire",
                                    treeId: treeId_2,
                                    childId: patchEvent_1.id,
                                    newParentId: patchEvent_1.slice.parent.id,
                                    newIndex: patchEvent_1.slice.parent.index,
                                    oldIndex: oldIndex_1,
                                    oldParentId: oldParentId_1,
                                }, { name: name, meta: meta });
                            });
                        }
                        return;
                    }
                    else {
                        console.error("The parent field's id and index must be updated together. Ignoring the patch event.");
                        return;
                    }
                }
                // patch other fields
                tree(treeId_2).nodes[patchEvent_1.id]["state"] = (0, lodash_1.mergeWith)(newState, JSON.parse(JSON.stringify(patchEvent_1.slice)), mergeStateCustomizer);
                forestUpdateSubscribers.forEach(function (cb) {
                    cb({ type: "change", id: patchEvent_1.id, treeId: treeId_2, oldState: oldState_1 }, { name: name, meta: meta });
                });
            }
        }
        if (event.type.startsWith("DELETE")) {
            var delEvent_1 = event;
            var treeId_3 = delEvent_1.type.slice("DELETE$$".length);
            // find all children and add them to be delete array
            var nodesToBeDeleted = [delEvent_1.id];
            var reverseMap = createReverseMap(treeMap[treeId_3].nodes);
            var currentIndex = 0;
            while (currentIndex < nodesToBeDeleted.length) {
                var currentNodeId = nodesToBeDeleted[currentIndex];
                if (reverseMap[currentNodeId]) {
                    nodesToBeDeleted.push.apply(nodesToBeDeleted, reverseMap[currentNodeId]);
                }
                currentIndex++;
            }
            var topNode_1 = treeMap[treeId_3].nodes[delEvent_1.id];
            var copyOfNodesToBeDeleted_1 = JSON.parse(JSON.stringify(nodesToBeDeleted.map(function (id) {
                return treeMap[treeId_3].nodes[id];
            })));
            nodesToBeDeleted.reverse().forEach(function (nodeId) {
                if (treeMap[treeId_3].nodes[nodeId] === undefined) {
                    console.log(delEvent_1.id, topNode_1, nodeId);
                }
                var parentId = treeMap[treeId_3].nodes[nodeId].state.parent.id;
                var deletedNode = treeMap[treeId_3].nodes[nodeId];
                delete treeMap[treeId_3].nodes[nodeId];
                forestUpdateSubscribers.forEach(function (cb) {
                    cb({
                        type: "dewire",
                        childId: nodeId,
                        parentId: parentId,
                        treeId: treeId_3,
                        deletedNode: deletedNode,
                        topNode: topNode_1,
                        deletedNodes: copyOfNodesToBeDeleted_1,
                    }, { name: name, meta: meta });
                });
            });
        }
        if (event.type.startsWith("LINK")) {
            var linkEvent_1 = event;
            var treeId_4 = linkEvent_1.type.slice("LINK$$".length);
            treeMap[treeId_4].links[linkEvent_1.refId] = linkEvent_1;
            // record all link events in the forest to process unlink
            // called as a result of deleting something in root tree
            linkEvents[linkEvent_1.refId]
                ? (_e = linkEvents[linkEvent_1.refId]) === null || _e === void 0 ? void 0 : _e.push(linkEvent_1)
                : (linkEvents[linkEvent_1.refId] = [linkEvent_1]);
            forestUpdateSubscribers.forEach(function (cb) {
                cb({
                    type: "link",
                    refId: linkEvent_1.refId,
                    childId: linkEvent_1.childId,
                    treeId: treeId_4,
                    rootTreeId: rootDef.id,
                }, { name: name, meta: meta });
            });
        }
        if (event.type.startsWith("UNLINK")) {
            var unlinkEvent_1 = event;
            var treeId_5 = unlinkEvent_1.type.slice("UNLINK$$".length);
            delete treeMap[treeId_5].links[unlinkEvent_1.refId];
            forestUpdateSubscribers.forEach(function (cb) {
                cb({
                    type: "unlink",
                    refId: unlinkEvent_1.refId,
                    childId: unlinkEvent_1.childId,
                    treeId: treeId_5,
                    rootTreeId: rootDef.id,
                }, { name: name, meta: meta });
            });
        }
        if (event.type.startsWith("HARDPATCH")) {
            var patchEvent_2 = event;
            var treeId_6 = patchEvent_2.type.slice("HARDPATCH$$".length);
            var tree_2 = treeMap[treeId_6];
            if (patchEvent_2.selector === undefined) {
                var patchEventHasParent = "parent" in patchEvent_2.state;
                var oldState_2 = JSON.parse(JSON.stringify(tree_2.nodes[patchEvent_2.id].state));
                var oldParent_1 = JSON.parse(JSON.stringify(tree_2.nodes[patchEvent_2.id].state.parent));
                // add parent field if not present
                if (!patchEventHasParent) {
                    patchEvent_2.state.parent = tree_2.nodes[patchEvent_2.id].state.parent;
                }
                tree_2.nodes[patchEvent_2.id].state = patchEvent_2.state;
                // emit rewire event only if parent has changed
                if (patchEventHasParent &&
                    (patchEvent_2.state.parent.id !== oldParent_1.id ||
                        patchEvent_2.state.parent.index !== oldParent_1.index)) {
                    forestUpdateSubscribers.forEach(function (cb) {
                        cb({
                            type: "rewire",
                            treeId: treeId_6,
                            childId: patchEvent_2.id,
                            newParentId: patchEvent_2.state.parent.id,
                            newIndex: patchEvent_2.state.parent.index,
                            oldIndex: oldParent_1.index,
                            oldParentId: oldParent_1.id,
                        }, { name: name, meta: meta });
                    });
                }
                // emit change event
                forestUpdateSubscribers.forEach(function (cb) {
                    cb({ type: "change", id: patchEvent_2.id, treeId: treeId_6, oldState: oldState_2 }, { name: name, meta: meta });
                });
            }
            else {
                // store old state
                var oldState_3 = JSON.parse(JSON.stringify(tree_2.nodes[patchEvent_2.id].state));
                var selector = patchEvent_2.selector;
                var curr = tree_2.nodes[patchEvent_2.id].state;
                // get or create selector fields
                for (var i = 0; i < selector.length; i++) {
                    var currentSelector = selector[i];
                    if (!(currentSelector in curr)) {
                        curr[currentSelector] = {};
                    }
                    if (i === selector.length - 1) {
                        // assign new state
                        curr[currentSelector] = patchEvent_2.state;
                    }
                    else {
                        curr = curr[currentSelector];
                    }
                }
                // emit change event
                forestUpdateSubscribers.forEach(function (cb) {
                    cb({ type: "change", id: patchEvent_2.id, treeId: treeId_6, oldState: oldState_3 }, { name: name, meta: meta });
                });
            }
        }
    }
    function handleEvents(data) {
        var name = data.name, events = data.events, meta = data.meta;
        events.forEach(function (event) {
            handleEvent(name, event, meta);
        });
    }
    // create a node
    function create(event, meta) {
        var type = event.type.slice("CREATE$$".length);
        handleEvents({ name: "", events: [event], meta: meta });
        defaultFnMap[type].onCreate(event);
    }
    // patch a node
    function patch(event, meta) {
        handleEvents({ name: "", events: [event], meta: meta });
    }
    // delete a node
    function del(event, meta) {
        handleEvents({ name: "", events: [event], meta: meta });
    }
    // link nodes between two trees
    function link(event, meta) {
        handleEvents({ name: "", events: [event], meta: meta });
    }
    // unlink nodes between two trees
    function unlink(event, meta) {
        handleEvents({ name: "", events: [event], meta: meta });
    }
    // subscibe forest
    function subscribeForest(cb) {
        forestUpdateSubscribers.push(cb);
        return function () {
            var index = forestUpdateSubscribers.findIndex(function (curr) { return curr === cb; });
            if (index >= 0) {
                forestUpdateSubscribers.splice(index, 1);
            }
        };
    }
    var forest = {
        tree: tree,
        create: create,
        patch: patch,
        del: del,
        link: link,
        unlink: unlink,
        handleEvents: handleEvents,
        subscribeForest: subscribeForest,
    };
    // create trees and add it to the map
    treeDefs.forEach(function (def) {
        var tree = (0, tree_1.createTree)(def, forest);
        treeMap[def.modulePath] = tree;
    });
    return forest;
}
exports.createForest = createForest;
//# sourceMappingURL=forest.js.map