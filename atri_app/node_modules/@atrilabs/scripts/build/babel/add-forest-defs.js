"use strict";
var generateModuleId = require("./generateModuleId");
/**
 *
 * @param {string} forestPkg
 */
function forestId(forestPkg) {
    return generateModuleId(forestPkg);
}
// treeId is the import path of the tree's default function
/**
 *
 * @param {{modulePath: string;}} tree
 * @returns {string}
 */
function treeId(tree) {
    return generateModuleId(tree.modulePath);
}
/**
 *
 * @param {{[forestPkg: string]: {modulePath: string;}[]}} forests
 * @returns {{[modulePath: string]: {localIdentifier: string, treeId: string}}}
 */
function generateImportMap(forests) {
    var forestPkgs = Object.keys(forests);
    var treeCount = 1;
    var treeImportMap = {};
    forestPkgs.forEach(function (forestPkg) {
        var forest = forests[forestPkg];
        forest.forEach(function (tree) {
            treeImportMap[tree.modulePath] = {
                localIdentifier: "tree" + treeCount++,
                treeId: treeId(tree),
            };
        });
    });
    return treeImportMap;
}
/**
 *
 * @param {*} t
 * @param {{[modulePath: string]: {localIdentifier: string, treeId: string}}} treeImportMap
 * @returns
 */
function generateImportStatements(t, treeImportMap) {
    var keys = Object.keys(treeImportMap);
    return keys.map(function (key) {
        var identifier = t.identifier(treeImportMap[key].localIdentifier);
        var importDefaultSpecifier = t.importDefaultSpecifier(identifier);
        var importDeclaration = t.importDeclaration([importDefaultSpecifier], t.stringLiteral(key));
        return importDeclaration;
    });
}
/**
 *
 * @param {*} t
 * @param {{modulePath: string;}[]} forest
 * @param {{[modulePath: string]: {localIdentifier: string, treeId: string}}} treeImportMap
 * @returns
 */
function generateTreeDefArray(t, forest, treeImportMap) {
    var treeDefObjects = forest.map(function (tree) {
        var idProp = t.objectProperty(t.identifier("id"), t.stringLiteral(treeImportMap[tree.modulePath].treeId));
        var modulePathProp = t.objectProperty(t.identifier("modulePath"), t.stringLiteral(tree.modulePath));
        var defFn = t.identifier(treeImportMap[tree.modulePath].localIdentifier);
        var defFnProp = t.objectProperty(t.identifier("defFn"), defFn);
        var treeDefObject = t.objectExpression([
            idProp,
            modulePathProp,
            defFnProp,
        ]);
        return treeDefObject;
    });
    return t.arrayExpression(treeDefObjects);
}
/**
 *
 * @param {*} t
 * @param {{[forestPkg: string]: {modulePath: string;}[]}} forests
 * @param {{[treeId: string]: {localIdentifier: string, treeId: string}}} treeImportMap
 * @returns
 */
function generateForestDefArray(t, forests, treeImportMap) {
    var forestPkgs = Object.keys(forests);
    // generate properties for each forest
    var forestDefs = forestPkgs.map(function (forestPkg) {
        var idProp = t.objectProperty(t.identifier("id"), t.stringLiteral(forestId(forestPkg)));
        var pkgProp = t.objectProperty(t.identifier("pkg"), t.stringLiteral(forestPkg));
        var trees = forests[forestPkg];
        var treesProp = t.objectProperty(t.identifier("trees"), generateTreeDefArray(t, trees, treeImportMap));
        return t.objectExpression([idProp, pkgProp, treesProp]);
    });
    // create object expression
    return t.arrayExpression(forestDefs);
}
var InternalVisitor = {
    VariableDeclarator: function (path) {
        var id = path.get("id");
        if (id.type === "Identifier" && id.node.name === "defs") {
            var init = path.get("init");
            var forestDefs = generateForestDefArray(this.t, this.options.forests, this.treeImportMap);
            init.replaceWith(forestDefs);
        }
    },
};
/**
 * The path to layer can be without extension.
 * @param {*} babel
 * @param {{forests: {[pkg: string]: {modulePath: string;}[]}, browserForestManagerFile: string}} options
 * @returns
 */
module.exports = function (babel, options) {
    // check options
    if (options.forests === undefined ||
        options.browserForestManagerFile === undefined) {
        // do nothing if options are incorrect
        return { visitor: {} };
    }
    return {
        visitor: {
            Program: function (path, parent) {
                if (!(parent.filename.includes(options.browserForestManagerFile))) {
                    return;
                }
                // add import statements for each tree
                var treeImportMap = generateImportMap(options.forests);
                var importStatements = generateImportStatements(babel.types, treeImportMap);
                importStatements.forEach(function (statement) {
                    path.unshiftContainer("body", statement);
                });
                path.traverse(InternalVisitor, {
                    options: options,
                    t: babel.types,
                    treeImportMap: treeImportMap,
                });
            },
        },
    };
};
//# sourceMappingURL=add-forest-defs.js.map