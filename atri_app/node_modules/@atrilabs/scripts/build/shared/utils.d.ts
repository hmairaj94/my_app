import { ManifestConfig, ManifestSchemaConfig, ToolConfig } from "@atrilabs/core";
import { CorePkgInfo, LayerEntry, ManifestPkgInfo, ManifestSchemaEntry, ManifestSchemaPkgInfo, RuntimeEntry, ToolEnv, ToolPkgInfo } from "./types";
export declare function getToolPkgInfo(): ToolPkgInfo;
export declare function getCorePkgInfo(): CorePkgInfo;
export declare function getToolEnv(): ToolEnv;
/**
 * importToolConfig will re-import tool.config.js on every call.
 * Reloading is needed in case tool.config.js has any changes during
 * development.
 */
export declare function importToolConfig(toolConfigFile: string): Promise<ToolConfig>;
/**
 * extractLayerEntries will re-import layer.config.js on every call.
 * Reloading is needed in case layer.config.js has any changes during
 * development.
 */
export declare function extractLayerEntries(toolConfig: ToolConfig, toolPkgInfo: ToolPkgInfo): Promise<LayerEntry[]>;
export declare function getNameMapForPackage(entry: LayerEntry | RuntimeEntry): Partial<{
    menu: import("@atrilabs/core").NameMap;
    containers: import("@atrilabs/core").NameMap;
    tabs: import("@atrilabs/core").NameMap;
}> | Partial<{
    menu: import("@atrilabs/core").NameMap;
    containers: import("@atrilabs/core").NameMap;
    tabs: import("@atrilabs/core").NameMap;
}>;
export declare function detectLayerForFile(filename: string, layerEntries: LayerEntry[]): LayerEntry | undefined;
export declare function detectRuntimeForFile(filename: string, runtimeEntries: RuntimeEntry[]): RuntimeEntry | undefined;
/**
 * clear the cache directory.
 */
export declare function resetBuildCache(toolPkgInfo: ToolPkgInfo): void;
export declare function sortLayerEntriesInImportOrder(layerEntries: LayerEntry[]): LayerEntry[];
export declare function extractRuntimeEntries(toolConfig: ToolConfig): Promise<RuntimeEntry[]>;
export declare function getManifestSchemaPkgInfo(pkg: string): ManifestSchemaPkgInfo;
export declare function getManifestPkgInfo(pkg: string): ManifestPkgInfo;
export declare function importManifestConfig(manifestConfigFile: string): Promise<ManifestConfig>;
export declare function importManifestSchemaConfig(manfiestSchemaConfigFile: string): Promise<ManifestSchemaConfig>;
export declare function extractManifestPkgBuildType(manifestConfig: ManifestConfig): Promise<Set<"react">>;
export declare function extractManifestPkgBuildInfo(manifestPkgInfo: ManifestPkgInfo): Promise<{
    buildType: ManifestSchemaConfig["libs"]["0"];
    dir: string;
}>;
/**
 * The Manifest server might put a watch on a manifest package cache directory
 * hence, manifest package's cache directory will be needed.
 * This function just returns the path and doesn't actually creates it.
 */
export declare function getManifestPkgCacheDir(manifestPkgfInfo: ManifestPkgInfo): string;
/**
 * manifest server might have to copy manifest template to the cache directory
 * and treat it as an entry point for webpack build.
 */
export declare function copyManifestEntryTemplate(buildType: ManifestSchemaConfig["libs"]["0"], dest: string): void;
export declare function installDependencies(deps: {
    [pkg: string]: string;
}, pkgManager: ToolConfig["pkgManager"]): Promise<void>;
export declare function installManifestPkgDependencies(manifestPkgfInfo: ManifestPkgInfo, pkgManager: ToolConfig["pkgManager"]): Promise<void>;
export declare function getFiles(dir: string): string[];
export declare function copyFileSync(src: string, destDir: string): void;
/**
 * The manifest server will compile a typescript based manifest package.
 * the compiled assets will be put in outDir which is some location in cache dir.
 * All the files from srcDir that do not end with .ts, .tsx will be copied as is to outDir.
 */
export declare function compileTypescriptManifestPkg(srcDir: string, outDir: string): Promise<string[]>;
/**
 * manifest server will bundle the manifest package. The generated bundle will be sent
 * over to the manifest client.
 */
export declare function bundleManifestPkg(mode: "development" | "production", shouldUseSourceMap: boolean, entryPoint: string, output: {
    path: string;
    filename: string;
}, scriptName: string, publicPath: string, manifestJsPath: string, manifests: string[], shimsPath: string, ignoreShimsDir: string): Promise<void>;
export declare function extractManifestSchemaEntry(manifestSchemaPkg: string): Promise<ManifestSchemaEntry>;
export declare function extractManifestSchemaEntries(toolConfig: ToolConfig): Promise<(ManifestSchemaPkgInfo & ManifestSchemaConfig)[]>;
export declare function isPromise(p: any): boolean;
//# sourceMappingURL=utils.d.ts.map