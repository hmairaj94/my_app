"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPromise = exports.extractManifestSchemaEntries = exports.extractManifestSchemaEntry = exports.bundleManifestPkg = exports.compileTypescriptManifestPkg = exports.copyFileSync = exports.getFiles = exports.installManifestPkgDependencies = exports.installDependencies = exports.copyManifestEntryTemplate = exports.getManifestPkgCacheDir = exports.extractManifestPkgBuildInfo = exports.extractManifestPkgBuildType = exports.importManifestSchemaConfig = exports.importManifestConfig = exports.getManifestPkgInfo = exports.getManifestSchemaPkgInfo = exports.extractRuntimeEntries = exports.sortLayerEntriesInImportOrder = exports.resetBuildCache = exports.detectRuntimeForFile = exports.detectLayerForFile = exports.getNameMapForPackage = exports.extractLayerEntries = exports.importToolConfig = exports.getToolEnv = exports.getCorePkgInfo = exports.getToolPkgInfo = void 0;
var path_1 = __importDefault(require("path"));
var fs_1 = __importDefault(require("fs"));
var chalk_1 = __importDefault(require("chalk"));
var ts = __importStar(require("typescript"));
var webpack_1 = require("webpack");
var lodash_1 = require("lodash");
var manifest_webpack_config_1 = __importDefault(require("./manifest.webpack.config"));
var child_process_1 = require("child_process");
// NOTE: this script is expected to be run via a package manager like npm, yarn
// packaged layers will always have js/jsx extension
var moduleFileExtensions = ["js", "jsx"];
/**
 *
 * @param filename file name without extension
 */
function findFileWithoutExtension(filename) {
    for (var i = 0; i < moduleFileExtensions.length; i++) {
        var ext = moduleFileExtensions[i];
        var filenameWithExt = "".concat(filename, ".").concat(ext);
        if (fs_1.default.existsSync(filenameWithExt) &&
            !fs_1.default.statSync(filenameWithExt).isDirectory()) {
            // add this to layer entries
            return filenameWithExt;
        }
    }
    return;
}
function getToolPkgInfo() {
    var toolDir = path_1.default.resolve(process.env["TOOL_ROOT_PATH"] || process.cwd());
    var toolSrc = path_1.default.resolve(toolDir, "src");
    var toolConfigFile = path_1.default.resolve(toolSrc, "tool.config.js");
    var toolNodeModule = path_1.default.resolve(toolDir, "node_modules");
    var cacheDir = path_1.default.resolve(toolNodeModule, ".cache", "@atrilabs", "build");
    var publicDir = path_1.default.resolve(toolDir, "public");
    var toolHtml = path_1.default.resolve(publicDir, "index.html");
    return {
        dir: toolDir,
        src: toolSrc,
        configFile: toolConfigFile,
        nodeModule: toolNodeModule,
        cacheDir: cacheDir,
        publicDir: publicDir,
        toolHtml: toolHtml,
    };
}
exports.getToolPkgInfo = getToolPkgInfo;
function getCorePkgInfo() {
    var dir = path_1.default.dirname(require.resolve("@atrilabs/core/package.json"));
    var entryFile = findFileWithoutExtension(path_1.default.resolve(dir, "lib", "layers"));
    var indexFile = findFileWithoutExtension(path_1.default.resolve(dir, "lib", "index"));
    var layerDetailsFile = findFileWithoutExtension(path_1.default.resolve(dir, "lib", "layerDetails"));
    var browserForestManagerFile = findFileWithoutExtension(path_1.default.resolve(dir, "lib", "browserForestManager"));
    var manifestRegistryFile = findFileWithoutExtension(path_1.default.resolve(dir, "lib", "manifestRegistry"));
    var apiFile = findFileWithoutExtension(path_1.default.resolve(dir, "lib", "api"));
    if (entryFile === undefined ||
        indexFile === undefined ||
        layerDetailsFile === undefined ||
        browserForestManagerFile === undefined ||
        manifestRegistryFile === undefined ||
        apiFile === undefined) {
        throw Error(chalk_1.default.red("Missing a entryFile or indexFile in @atrilabs/core"));
    }
    return {
        dir: path_1.default.dirname(require.resolve("@atrilabs/core/package.json")),
        entryFile: entryFile,
        indexFile: indexFile,
        layerDetailsFile: layerDetailsFile,
        browserForestManagerFile: browserForestManagerFile,
        manifestRegistryFile: manifestRegistryFile,
        apiFile: apiFile,
    };
}
exports.getCorePkgInfo = getCorePkgInfo;
function getToolEnv() {
    return {
        PUBLIC_URL: "",
    };
}
exports.getToolEnv = getToolEnv;
/**
 * importToolConfig will re-import tool.config.js on every call.
 * Reloading is needed in case tool.config.js has any changes during
 * development.
 */
function importToolConfig(toolConfigFile) {
    function toolConfigExists() {
        // <toolDir>/src/tool.config.(ts|js) should exist
        if (fs_1.default.existsSync(toolConfigFile)) {
            return true;
        }
        return false;
    }
    if (toolConfigExists()) {
        delete require.cache[toolConfigFile];
        // TODO: do schema check before returning
        return Promise.resolve().then(function () { return __importStar(require(toolConfigFile)); }).then(function (mod) { return mod.default; });
    }
    else {
        throw Error("Module Not Found: ".concat(toolConfigFile));
    }
}
exports.importToolConfig = importToolConfig;
/**
 * extractLayerEntries will re-import layer.config.js on every call.
 * Reloading is needed in case layer.config.js has any changes during
 * development.
 */
function extractLayerEntries(toolConfig, toolPkgInfo) {
    return __awaiter(this, void 0, void 0, function () {
        function getLayerInfo(layerConfigPath) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, new Promise(function (res) {
                            // delete cache to re-import layer.config.js module
                            delete require.cache[layerConfigPath];
                            Promise.resolve().then(function () { return __importStar(require(layerConfigPath)); }).then(function (mod) {
                                res({
                                    layerEntryModulePath: mod.default.modulePath,
                                    requires: mod.default.requires,
                                    exposes: mod.default.exposes,
                                    runtime: mod.default.runtime,
                                });
                                return;
                            });
                        })];
                });
            });
        }
        var layerEntries, layers, i, layer, remap, layerConfigPaths, layerConfigPath, i_1, layerPath, layerSrcDir, layerPackageName, globalModulePath, importGlobalModulePath, layerConfigSymlink, _a, layerEntryModulePath, exposes, requires, runtime, layerEntry, isRoot, err_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    layerEntries = [];
                    layers = toolConfig.layers;
                    i = 0;
                    _b.label = 1;
                case 1:
                    if (!(i < layers.length)) return [3 /*break*/, 6];
                    layer = layers[i].pkg;
                    remap = layers[i].remap;
                    layerConfigPaths = [require.resolve("".concat(layer, "/lib/layer.config.js"))];
                    layerConfigPath = undefined;
                    for (i_1 = 0; i_1 < layerConfigPaths.length; i_1++) {
                        if (fs_1.default.existsSync(layerConfigPaths[i_1])) {
                            layerConfigPath = layerConfigPaths[i_1];
                        }
                    }
                    if (layerConfigPath === undefined) {
                        console.error("Error: layer config not found at following location\n", layerConfigPaths.join("\n"));
                        // skip the layer
                        return [3 /*break*/, 5];
                    }
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 4, , 5]);
                    layerPath = path_1.default.dirname(require.resolve("".concat(layer, "/package.json")));
                    layerSrcDir = path_1.default.resolve(layerPath, "src");
                    layerPackageName = layer;
                    globalModulePath = path_1.default.resolve(toolPkgInfo.cacheDir, layer, "index.js");
                    importGlobalModulePath = path_1.default
                        .join(".cache", layer, "index.js")
                        .replace(/\\/g, "/");
                    layerConfigSymlink = path_1.default.resolve(toolPkgInfo.cacheDir, layer, "layer.config.js");
                    return [4 /*yield*/, getLayerInfo(layerConfigPath)];
                case 3:
                    _a = _b.sent(), layerEntryModulePath = _a.layerEntryModulePath, exposes = _a.exposes, requires = _a.requires, runtime = _a.runtime;
                    layerEntry = path_1.default
                        .join(layer, "lib", layerEntryModulePath)
                        .replace(/\\/g, "/");
                    isRoot = i === 0 ? true : false;
                    layerEntries.push({
                        index: i,
                        layerEntry: layerEntry,
                        isRoot: isRoot,
                        layerConfigPath: layerConfigPath,
                        layerPath: layerPath,
                        globalModulePath: globalModulePath,
                        layerConfigSymlink: layerConfigSymlink,
                        layerPackageName: layerPackageName,
                        importGlobalModulePath: importGlobalModulePath,
                        exposes: exposes,
                        requires: requires,
                        remap: remap,
                        layerSrcDir: layerSrcDir,
                        runtime: runtime,
                    });
                    return [3 /*break*/, 5];
                case 4:
                    err_1 = _b.sent();
                    console.log(err_1);
                    return [3 /*break*/, 5];
                case 5:
                    i++;
                    return [3 /*break*/, 1];
                case 6: return [2 /*return*/, layerEntries];
            }
        });
    });
}
exports.extractLayerEntries = extractLayerEntries;
function getNameMapForPackage(entry) {
    /**
     * Create name map for all layers
     * ------------------------------
     * Name map is a map between local name and global name.
     *
     * Step 1. Merge exposes and requires of layer. This step is necessary
     * because it might happen that the layer itself is using the menu etc. that
     * it has exposed.
     *
     * Step 2. Merge remap of the layer with the layer config with precedence to
     * remap in tool config.
     */
    var namemap = {};
    (0, lodash_1.merge)(namemap, entry.exposes, entry.requires);
    (0, lodash_1.merge)(namemap, entry.remap || {});
    return namemap;
}
exports.getNameMapForPackage = getNameMapForPackage;
function detectLayerForFile(filename, layerEntries) {
    for (var i = 0; i < layerEntries.length; i++) {
        var currLayer = layerEntries[i];
        if (filename.includes(currLayer.layerPath)) {
            return currLayer;
        }
    }
    return;
}
exports.detectLayerForFile = detectLayerForFile;
function detectRuntimeForFile(filename, runtimeEntries) {
    for (var i = 0; i < runtimeEntries.length; i++) {
        var currRuntime = runtimeEntries[i];
        if (filename.includes(currRuntime.runtimePath)) {
            return currRuntime;
        }
    }
    return;
}
exports.detectRuntimeForFile = detectRuntimeForFile;
/**
 * clear the cache directory.
 */
function resetBuildCache(toolPkgInfo) {
    if (fs_1.default.existsSync(toolPkgInfo.cacheDir)) {
        fs_1.default.rmSync(toolPkgInfo.cacheDir, { force: true, recursive: true });
    }
    fs_1.default.mkdirSync(toolPkgInfo.cacheDir, { recursive: true });
}
exports.resetBuildCache = resetBuildCache;
function sortLayerEntriesInImportOrder(layerEntries) {
    var sorted = __spreadArray([], layerEntries, true);
    sorted.sort(function (a, b) {
        return a.index - b.index;
    });
    return sorted;
}
exports.sortLayerEntriesInImportOrder = sortLayerEntriesInImportOrder;
function extractRuntimeEntries(toolConfig) {
    return __awaiter(this, void 0, void 0, function () {
        function getRuntimeInfo(runtimeConfigPath) {
            return new Promise(function (res) {
                // delete cache to re-import layer.config.js module
                delete require.cache[runtimeConfigPath];
                Promise.resolve().then(function () { return __importStar(require(runtimeConfigPath)); }).then(function (mod) {
                    res({
                        runtimeEntryModulePath: mod.default.modulePath,
                        requires: mod.default.requires,
                        exposes: mod.default.exposes,
                    });
                });
            });
        }
        var runtimeEntries, runtimes, i, runtime, remap, runtimeConfigPaths, runtimeConfigPath, i_2, runtimePath, runtimeSrcDir, runtimePackageName, _a, runtimeEntryModulePath, exposes, requires, err_2;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    runtimeEntries = [];
                    runtimes = toolConfig.runtimes;
                    i = 0;
                    _b.label = 1;
                case 1:
                    if (!(i < runtimes.length)) return [3 /*break*/, 6];
                    runtime = runtimes[i].pkg;
                    remap = runtimes[i].remap;
                    runtimeConfigPaths = [
                        require.resolve("".concat(runtime, "/lib/runtime.config.js")),
                    ];
                    runtimeConfigPath = undefined;
                    for (i_2 = 0; i_2 < runtimeConfigPaths.length; i_2++) {
                        if (fs_1.default.existsSync(runtimeConfigPaths[i_2])) {
                            runtimeConfigPath = runtimeConfigPaths[i_2];
                        }
                    }
                    if (runtimeConfigPath === undefined) {
                        console.error("Error: layer config not found at following location\n", runtimeConfigPaths.join("\n"));
                        // skip the layer
                        return [3 /*break*/, 5];
                    }
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 4, , 5]);
                    runtimePath = path_1.default.dirname(require.resolve("".concat(runtime, "/package.json")));
                    runtimeSrcDir = path_1.default.resolve(runtimePath, "src");
                    runtimePackageName = runtime;
                    return [4 /*yield*/, getRuntimeInfo(runtimeConfigPath)];
                case 3:
                    _a = _b.sent(), runtimeEntryModulePath = _a.runtimeEntryModulePath, exposes = _a.exposes, requires = _a.requires;
                    runtimeEntries.push({
                        index: i,
                        runtimeEntry: path_1.default
                            .join(runtime, "lib", runtimeEntryModulePath)
                            .replace(/\\/g, "/"),
                        runtimeConfigPath: runtimeConfigPath,
                        runtimePath: runtimePath,
                        runtimePackageName: runtimePackageName,
                        exposes: exposes,
                        requires: requires,
                        remap: remap,
                        runtimeSrcDir: runtimeSrcDir,
                    });
                    return [3 /*break*/, 5];
                case 4:
                    err_2 = _b.sent();
                    console.log(err_2);
                    return [3 /*break*/, 5];
                case 5:
                    i++;
                    return [3 /*break*/, 1];
                case 6: return [2 /*return*/, runtimeEntries];
            }
        });
    });
}
exports.extractRuntimeEntries = extractRuntimeEntries;
function getManifestSchemaPkgInfo(pkg) {
    var schemaPath = path_1.default.dirname(require.resolve("".concat(pkg, "/package.json")));
    var srcDir = path_1.default.resolve(schemaPath, "lib");
    var configFile = path_1.default.resolve(srcDir, "manifest.schema.config.js");
    var manifestId = pkg;
    return { pkg: pkg, schemaPath: schemaPath, srcDir: srcDir, configFile: configFile, manifestId: manifestId };
}
exports.getManifestSchemaPkgInfo = getManifestSchemaPkgInfo;
function getManifestPkgInfo(pkg) {
    var packageJSON = require.resolve("".concat(pkg, "/package.json"));
    var manifestPath = path_1.default.dirname(packageJSON);
    var srcDir = path_1.default.resolve(manifestPath, "src");
    var configFile = path_1.default.resolve(srcDir, "manifest.config.js");
    return { pkg: pkg, manifestPath: manifestPath, srcDir: srcDir, configFile: configFile, packageJSON: packageJSON };
}
exports.getManifestPkgInfo = getManifestPkgInfo;
function importManifestConfig(manifestConfigFile) {
    return __awaiter(this, void 0, void 0, function () {
        function manifestConfigExists() {
            // <toolDir>/src/tool.config.(ts|js) should exist
            if (fs_1.default.existsSync(manifestConfigFile)) {
                return true;
            }
            return false;
        }
        return __generator(this, function (_a) {
            if (manifestConfigExists()) {
                delete require.cache[manifestConfigFile];
                // TODO: do schema check before returning
                return [2 /*return*/, Promise.resolve().then(function () { return __importStar(require(manifestConfigFile)); }).then(function (mod) { return mod.default; })];
            }
            else {
                throw Error("Module Not Found: ".concat(manifestConfigFile));
            }
            return [2 /*return*/];
        });
    });
}
exports.importManifestConfig = importManifestConfig;
function importManifestSchemaConfig(manfiestSchemaConfigFile) {
    return __awaiter(this, void 0, void 0, function () {
        function manifestConfigExists() {
            // <toolDir>/src/tool.config.(ts|js) should exist
            if (fs_1.default.existsSync(manfiestSchemaConfigFile)) {
                return true;
            }
            return false;
        }
        return __generator(this, function (_a) {
            if (manifestConfigExists()) {
                delete require.cache[manfiestSchemaConfigFile];
                // TODO: do schema check before returning
                return [2 /*return*/, Promise.resolve().then(function () { return __importStar(require(manfiestSchemaConfigFile)); }).then(function (mod) { return mod.default; })];
            }
            else {
                throw Error("Module Not Found: ".concat(manfiestSchemaConfigFile));
            }
            return [2 /*return*/];
        });
    });
}
exports.importManifestSchemaConfig = importManifestSchemaConfig;
// extract build type (libs) for a manifest pkg
function extractManifestPkgBuildType(manifestConfig) {
    return __awaiter(this, void 0, void 0, function () {
        var buildTypes, i, manifestSchemaPkg, manifestSchemaPkgInfo, manifestSchemaConfig;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    buildTypes = new Set();
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < manifestConfig.manifestSchema.length)) return [3 /*break*/, 4];
                    manifestSchemaPkg = manifestConfig.manifestSchema[i];
                    manifestSchemaPkgInfo = getManifestSchemaPkgInfo(manifestSchemaPkg.pkg);
                    return [4 /*yield*/, importManifestSchemaConfig(manifestSchemaPkgInfo.configFile)];
                case 2:
                    manifestSchemaConfig = _a.sent();
                    if (manifestSchemaConfig.libs) {
                        if (Array.isArray(manifestSchemaConfig.libs)) {
                            manifestSchemaConfig.libs.forEach(function (buildType) {
                                buildTypes.add(buildType);
                            });
                        }
                        else {
                            throw Error("Invalid manifest schema config in ".concat(manifestSchemaPkgInfo.configFile, ". Libs field must be an array of string."));
                        }
                    }
                    else {
                        throw Error("Invalid manifest schema config in ".concat(manifestSchemaPkgInfo.configFile, ". Missing libs field."));
                    }
                    _a.label = 3;
                case 3:
                    i++;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/, buildTypes];
            }
        });
    });
}
exports.extractManifestPkgBuildType = extractManifestPkgBuildType;
// extract build type (libs) and collect default exports from manifest dir
function extractManifestPkgBuildInfo(manifestPkgInfo) {
    return __awaiter(this, void 0, void 0, function () {
        var manifestConfig, buildTypes, buildType, dir;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, importManifestConfig(manifestPkgInfo.configFile)];
                case 1:
                    manifestConfig = _a.sent();
                    return [4 /*yield*/, extractManifestPkgBuildType(manifestConfig)];
                case 2:
                    buildTypes = _a.sent();
                    if (buildTypes.size > 1) {
                        throw Error("We currently don't support manifest schemas of more than one build type in a single package.");
                    }
                    if (buildTypes.size === 0) {
                        throw Error("Build type cannot be inferred for the manifest package ".concat(manifestPkgInfo.pkg));
                    }
                    buildType = Array.from(buildTypes)[0];
                    dir = path_1.default.resolve(path_1.default.dirname(manifestPkgInfo.configFile), manifestConfig.dir);
                    return [2 /*return*/, { buildType: buildType, dir: dir }];
            }
        });
    });
}
exports.extractManifestPkgBuildInfo = extractManifestPkgBuildInfo;
/**
 * The Manifest server might put a watch on a manifest package cache directory
 * hence, manifest package's cache directory will be needed.
 * This function just returns the path and doesn't actually creates it.
 */
function getManifestPkgCacheDir(manifestPkgfInfo) {
    var cacheDir = getToolPkgInfo()["cacheDir"];
    return path_1.default.resolve(cacheDir, "manifests", manifestPkgfInfo.pkg);
}
exports.getManifestPkgCacheDir = getManifestPkgCacheDir;
/**
 * manifest server might have to copy manifest template to the cache directory
 * and treat it as an entry point for webpack build.
 */
function copyManifestEntryTemplate(buildType, dest) {
    if (buildType === "react") {
        var shimPath = path_1.default.dirname(require.resolve("@atrilabs/manifest-shims/package.json"));
        var reactShimDir = path_1.default.resolve(shimPath, "lib", "react");
        var files = getFiles(reactShimDir);
        files.forEach(function (file) {
            copyFileSync(file, dest);
        });
    }
}
exports.copyManifestEntryTemplate = copyManifestEntryTemplate;
// deps is map of package name and version
function installDependencies(deps, pkgManager) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (res) {
                    var stringified = Object.keys(deps)
                        .map(function (key) {
                        var version = deps[key];
                        return "".concat(key, "@").concat(version);
                    })
                        .join(" ");
                    var callback = function (err, stdout, stderr) {
                        if (err) {
                            console.log("Error:\n".concat(err));
                        }
                        if (stdout) {
                            console.log("stdout:\n".concat(stdout));
                        }
                        if (stderr) {
                            console.log("stdout:\n".concat(stderr));
                        }
                        res();
                    };
                    if (pkgManager === "npm") {
                        (0, child_process_1.exec)("".concat(pkgManager, " install ").concat(stringified), callback);
                    }
                    if (pkgManager === "yarn") {
                        (0, child_process_1.exec)("".concat(pkgManager, " add ").concat(stringified), callback);
                    }
                })];
        });
    });
}
exports.installDependencies = installDependencies;
function installManifestPkgDependencies(manifestPkgfInfo, pkgManager) {
    return __awaiter(this, void 0, void 0, function () {
        var dependencies;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!fs_1.default.existsSync(manifestPkgfInfo.packageJSON)) return [3 /*break*/, 2];
                    dependencies = require(manifestPkgfInfo.packageJSON)["dependencies"];
                    return [4 /*yield*/, installDependencies(dependencies, pkgManager)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    });
}
exports.installManifestPkgDependencies = installManifestPkgDependencies;
function getFiles(dir) {
    var files = [];
    var dirents = fs_1.default.readdirSync(dir, { withFileTypes: true });
    dirents.forEach(function (dirent) {
        if (dirent.isDirectory()) {
            files.push.apply(files, getFiles(path_1.default.resolve(dir, dirent.name)));
        }
        else {
            files.push(path_1.default.resolve(dir, dirent.name));
        }
    });
    return files;
}
exports.getFiles = getFiles;
function copyFileSync(src, destDir) {
    var filename = path_1.default.basename(src);
    var destPath = path_1.default.resolve(destDir, filename);
    if (!fs_1.default.existsSync(path_1.default.dirname(destPath))) {
        fs_1.default.mkdirSync(path_1.default.dirname(destPath), { recursive: true });
    }
    fs_1.default.writeFileSync(destPath, fs_1.default.readFileSync(src));
}
exports.copyFileSync = copyFileSync;
/**
 * The manifest server will compile a typescript based manifest package.
 * the compiled assets will be put in outDir which is some location in cache dir.
 * All the files from srcDir that do not end with .ts, .tsx will be copied as is to outDir.
 */
function compileTypescriptManifestPkg(srcDir, outDir) {
    var _this = this;
    var files = getFiles(srcDir);
    var tsFiles = [];
    var otherFiles = [];
    // divide files into two parts to be processed differently
    for (var i = 0; i < files.length; i++) {
        var file = files[i];
        var ext = path_1.default.extname(file);
        if (ext.endsWith(".ts") || ext.endsWith(".tsx")) {
            tsFiles.push(file);
        }
        else {
            otherFiles.push(file);
        }
    }
    // compile using typescript compiler api
    var compilePromises = [];
    var _loop_1 = function (i) {
        var file = tsFiles[i];
        var relativePath = path_1.default.dirname(path_1.default.relative(srcDir, file));
        var ext = path_1.default.extname(file);
        var filenameWithoutExt = path_1.default.basename(file, ext);
        var outputPath = path_1.default.resolve(outDir, relativePath, filenameWithoutExt + ".js");
        var outputDir = path_1.default.dirname(outputPath);
        var compilePromise = new Promise(function (res) {
            fs_1.default.readFile(file, function (err, data) { return __awaiter(_this, void 0, void 0, function () {
                var newCode, err_3;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (err) {
                                console.log(err);
                                return [2 /*return*/];
                            }
                            newCode = ts.transpileModule(data.toString(), {
                                compilerOptions: {
                                    target: ts.ScriptTarget.ES5,
                                    lib: ["dom", "dom.iterable", "esnext"],
                                    allowJs: true,
                                    skipLibCheck: true,
                                    esModuleInterop: true,
                                    allowSyntheticDefaultImports: true,
                                    strict: true,
                                    forceConsistentCasingInFileNames: true,
                                    noFallthroughCasesInSwitch: true,
                                    module: ts.ModuleKind.ES2020,
                                    moduleResolution: ts.ModuleResolutionKind.NodeJs,
                                    resolveJsonModule: true,
                                    isolatedModules: true,
                                    noEmit: false,
                                    jsx: ts.JsxEmit.ReactJSX,
                                    declaration: true,
                                    declarationMap: true,
                                    sourceMap: true,
                                    inlineSourceMap: true,
                                    inlineSources: true,
                                },
                                fileName: path_1.default.basename(file),
                            }).outputText;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 5]);
                            return [4 /*yield*/, fs_1.default.promises.stat(outputDir)];
                        case 2:
                            _a.sent();
                            return [3 /*break*/, 5];
                        case 3:
                            err_3 = _a.sent();
                            return [4 /*yield*/, fs_1.default.promises.mkdir(outputDir, { recursive: true })];
                        case 4:
                            _a.sent();
                            return [3 /*break*/, 5];
                        case 5:
                            fs_1.default.writeFile(outputPath, newCode, function () {
                                res(outputPath);
                            });
                            return [2 /*return*/];
                    }
                });
            }); });
        });
        compilePromises.push(compilePromise);
    };
    for (var i = 0; i < tsFiles.length; i++) {
        _loop_1(i);
    }
    // copy files that aren't compiler
    var copyPromsies = [];
    var _loop_2 = function (i) {
        var file = otherFiles[i];
        var relativePath = path_1.default.relative(srcDir, file);
        var copyDest = path_1.default.resolve(outDir, relativePath);
        var copyDestDir = path_1.default.dirname(copyDest);
        var copyPromise = new Promise(function (res) {
            fs_1.default.promises
                .stat(copyDestDir)
                .catch(function () {
                fs_1.default.mkdirSync(copyDestDir, { recursive: true });
            })
                .finally(function () {
                fs_1.default.promises.readFile(file).then(function (value) {
                    fs_1.default.promises.writeFile(copyDest, value).then(function () {
                        res();
                    });
                });
            });
        });
        copyPromsies.push(copyPromise);
    };
    for (var i = 0; i < otherFiles.length; i++) {
        _loop_2(i);
    }
    // return a promise that waits for both copy and compilation to finish
    // finally, returning an array of string output paths
    return Promise.all(__spreadArray(__spreadArray([], compilePromises, true), copyPromsies, true)).then(function () {
        return Promise.all(compilePromises);
    });
}
exports.compileTypescriptManifestPkg = compileTypescriptManifestPkg;
/**
 * manifest server will bundle the manifest package. The generated bundle will be sent
 * over to the manifest client.
 */
function bundleManifestPkg(mode, shouldUseSourceMap, entryPoint, output, scriptName, publicPath, manifestJsPath, manifests, shimsPath, ignoreShimsDir) {
    var webpackConfig = (0, manifest_webpack_config_1.default)(mode, shouldUseSourceMap, entryPoint, output, scriptName, publicPath, manifestJsPath, manifests, shimsPath, ignoreShimsDir);
    return new Promise(function (res, rej) {
        (0, webpack_1.webpack)(webpackConfig, function (err, stats) {
            var buildFailed = false;
            if (err) {
                buildFailed = true;
                console.error(err);
            }
            if (stats === null || stats === void 0 ? void 0 : stats.hasErrors()) {
                buildFailed = true;
                console.log(stats === null || stats === void 0 ? void 0 : stats.toJson().errors);
            }
            if (!buildFailed) {
                res();
            }
            else {
                rej();
            }
        });
    });
}
exports.bundleManifestPkg = bundleManifestPkg;
function extractManifestSchemaEntry(manifestSchemaPkg) {
    return __awaiter(this, void 0, void 0, function () {
        var manifestSchemaPkgInfo, manifestSchemaConfig, modulePath;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    manifestSchemaPkgInfo = getManifestSchemaPkgInfo(manifestSchemaPkg);
                    return [4 /*yield*/, importManifestSchemaConfig(manifestSchemaPkgInfo.configFile)];
                case 1:
                    manifestSchemaConfig = _a.sent();
                    modulePath = path_1.default
                        .join(manifestSchemaPkg, "lib", manifestSchemaConfig.modulePath)
                        .replace(/\\/g, "/");
                    return [2 /*return*/, __assign(__assign(__assign({}, manifestSchemaConfig), { modulePath: modulePath }), manifestSchemaPkgInfo)];
            }
        });
    });
}
exports.extractManifestSchemaEntry = extractManifestSchemaEntry;
function extractManifestSchemaEntries(toolConfig) {
    return __awaiter(this, void 0, void 0, function () {
        var pkgs;
        return __generator(this, function (_a) {
            pkgs = toolConfig.manifestSchema.map(function (schema) { return schema.pkg; });
            return [2 /*return*/, Promise.all(pkgs.map(function (pkg) { return extractManifestSchemaEntry(pkg); }))];
        });
    });
}
exports.extractManifestSchemaEntries = extractManifestSchemaEntries;
function isPromise(p) {
    if (p instanceof Promise) {
        return true;
    }
    return false;
}
exports.isPromise = isPromise;
//# sourceMappingURL=utils.js.map