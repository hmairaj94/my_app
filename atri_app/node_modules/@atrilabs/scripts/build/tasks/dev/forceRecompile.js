"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var chokidar_1 = __importDefault(require("chokidar"));
var fs_1 = __importDefault(require("fs"));
var processToolConfig_1 = require("./processToolConfig");
/**
 * Webpack doesn't watch files that doesn't get resolved in the build process.
 * Hence, this is a trick to force compilation.
 */
function forceRecompile(corePkgInfo, toolPkgInfo) {
    // forcing re-compile by re-writing core/lib/layers.js file
    var rewriteLayersJS = function () {
        var layersContent = fs_1.default.readFileSync(corePkgInfo.entryFile);
        fs_1.default.writeFileSync(corePkgInfo.entryFile, layersContent);
    };
    // layer configs that are not inside node_modules directory, are considered
    // as layers under development. Hence, we watch the layer.config.js files
    // for these layers.
    var addLayerConfigToWatch = function () {
        return (0, processToolConfig_1.processToolConfig)(toolPkgInfo).then(function (_a) {
            var layerEntries = _a.layerEntries;
            var configFiles = layerEntries
                .map(function (entry) {
                if (!entry.layerConfigPath.match(/node_modules/)) {
                    return entry.layerConfigPath;
                }
                return;
            })
                .filter(function (entry) { return entry !== undefined; });
            watcher.add(configFiles);
        });
    };
    var watcher = chokidar_1.default.watch([toolPkgInfo.configFile]);
    addLayerConfigToWatch();
    watcher.on("change", function (path) {
        if (path === toolPkgInfo.configFile) {
            addLayerConfigToWatch().then(rewriteLayersJS);
        }
        else {
            rewriteLayersJS();
        }
    });
}
exports.default = forceRecompile;
//# sourceMappingURL=forceRecompile.js.map