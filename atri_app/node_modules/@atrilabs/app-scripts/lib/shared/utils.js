"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildServerWithDefaults = exports.buildAppWithDefaults = exports.ssgOutputPath = exports.serverInfoFile = exports.serverInfoFilename = exports.buildInfoFile = exports.buildInfoFilename = exports.setNodeAndBabelEnv = exports.getMode = exports.buildServer = exports.buildApp = exports.moduleFileExtensions = exports.imageInlineSizeLimit = void 0;
var webpack_1 = require("webpack");
var server_webpack_config_1 = __importDefault(require("./server.webpack.config"));
var webpack_config_1 = __importDefault(require("./webpack.config"));
var path_1 = __importDefault(require("path"));
var fs_1 = __importDefault(require("fs"));
exports.imageInlineSizeLimit = parseInt(process.env["IMAGE_INLINE_SIZE_LIMIT"] || "10000");
exports.moduleFileExtensions = [
    "web.mjs",
    "mjs",
    "web.js",
    "js",
    "web.ts",
    "ts",
    "web.tsx",
    "tsx",
    "json",
    "web.jsx",
    "jsx",
];
var watchOptions = {
    ignored: "".concat(path_1.default.resolve("node_modules"), "/**"),
};
function buildApp(options) {
    var mode = options.mode, appEntry = options.appEntry, appHtml = options.appHtml, appOutput = options.appOutput, includes = options.includes, wsClientEntry = options.wsClientEntry, assetUrlPrefix = options.assetUrlPrefix;
    process.env["NODE_ENV"] = mode;
    process.env["BABEL_ENV"] = mode;
    var webpackConfig = (0, webpack_config_1.default)({
        paths: { appEntry: appEntry, appHtml: appHtml, appOutput: appOutput, includes: includes, wsClientEntry: wsClientEntry },
        mode: mode,
        publicUrlOrPath: "/",
        shouldUseSourceMap: false,
        assetUrlPrefix: assetUrlPrefix,
    });
    if (options.addWatchOptions) {
        webpackConfig.watch = true;
        webpackConfig.watchOptions = watchOptions;
    }
    return (0, webpack_1.webpack)(webpackConfig, function (err, stats) {
        if (err) {
            console.log("Error\n", err);
        }
        if (stats === null || stats === void 0 ? void 0 : stats.hasErrors) {
            console.log(stats.toString());
        }
    });
}
exports.buildApp = buildApp;
function buildServer(options) {
    var mode = options.mode, serverEntry = options.serverEntry, serverOutput = options.serverOutput, includes = options.includes, allowList = options.allowList, serverSideEntry = options.serverSideEntry;
    process.env["NODE_ENV"] = mode;
    process.env["BABEL_ENV"] = mode;
    var webpackConfig = (0, server_webpack_config_1.default)({
        paths: { serverEntry: serverEntry, serverOutput: serverOutput, includes: includes, serverSideEntry: serverSideEntry },
        mode: mode,
        publicUrlOrPath: "/",
        shouldUseSourceMap: false,
        allowList: allowList,
    });
    if (options.addWatchOptions) {
        webpackConfig.watch = true;
        webpackConfig.watchOptions = watchOptions;
    }
    return (0, webpack_1.webpack)(webpackConfig, function (err, stats) {
        if (err) {
            console.log("Error\n", err);
        }
        if (stats === null || stats === void 0 ? void 0 : stats.hasErrors) {
            console.log(stats.toString());
        }
    });
}
exports.buildServer = buildServer;
function getMode() {
    var mode = process.env["MODE"] &&
        (process.env["MODE"] === "production" ||
            process.env["MODE"] === "development")
        ? process.env["MODE"]
        : "development";
    return mode;
}
exports.getMode = getMode;
function setNodeAndBabelEnv(mode) {
    process.env["NODE_ENV"] = mode;
    process.env["BABEL_ENV"] = mode;
}
exports.setNodeAndBabelEnv = setNodeAndBabelEnv;
exports.buildInfoFilename = "atri-build-info.json";
exports.buildInfoFile = path_1.default.resolve(exports.buildInfoFilename);
exports.serverInfoFilename = "atri-server-info.json";
exports.serverInfoFile = path_1.default.resolve(exports.serverInfoFilename);
exports.ssgOutputPath = path_1.default.resolve("dist", "ssg");
function buildAppWithDefaults() {
    return new Promise(function (res, rej) {
        var mode = getMode();
        setNodeAndBabelEnv(mode);
        try {
            var buildInfo = JSON.parse(fs_1.default.readFileSync(exports.buildInfoFile).toString());
            if (buildInfo) {
                var appEntry = buildInfo["appEntry"];
                var appHtml = buildInfo["appHtml"];
                var appOutput = buildInfo["appOutput"];
                var appSrc = buildInfo["appSrc"];
                var manifestDirs = buildInfo["manifestDirs"];
                if (!(appEntry &&
                    typeof appEntry === "string" &&
                    appHtml &&
                    typeof appHtml === "string" &&
                    appOutput &&
                    typeof appOutput === "string" &&
                    appSrc &&
                    typeof appSrc === "string" &&
                    manifestDirs &&
                    Array.isArray(manifestDirs))) {
                    throw Error("Wrong schema of ".concat(exports.buildInfoFilename, "."));
                }
                var manifestPkgs = manifestDirs.map(function (manifestDef) {
                    if (manifestDef["pkg"]) {
                        return path_1.default.dirname(require.resolve("".concat(manifestDef.pkg, "/package.json")));
                    }
                    else {
                        throw Error("Wrong schema of ".concat(exports.buildInfoFilename, "."));
                    }
                });
                var includes = __spreadArray(__spreadArray([], manifestPkgs, true), [appSrc], false);
                var compiler = buildApp({
                    appEntry: path_1.default.resolve(appEntry),
                    appHtml: path_1.default.resolve(appHtml),
                    appOutput: path_1.default.resolve(appOutput),
                    includes: includes.map(function (inc) { return path_1.default.resolve(inc); }),
                    mode: mode,
                    addWatchOptions: false,
                    assetUrlPrefix: process.env["ASSET_URL_PREFIX"] || buildInfo.assetUrlPrefix,
                });
                compiler.hooks.done.tap("build with defaults", function (stats) {
                    res(stats);
                });
            }
            else {
                rej("Missing manifestDirs in ".concat(exports.buildInfoFilename));
            }
        }
        catch (err) {
            rej(err);
        }
    });
}
exports.buildAppWithDefaults = buildAppWithDefaults;
function buildServerWithDefaults() {
    return new Promise(function (res, rej) {
        var mode = getMode();
        setNodeAndBabelEnv(mode);
        // Where will I get manifest directories to include?
        try {
            var buildInfo = JSON.parse(fs_1.default.readFileSync(exports.buildInfoFile).toString());
            if (buildInfo) {
                var serverEntry = buildInfo["serverEntry"];
                var serverSideEntry = buildInfo["serverSideEntry"];
                var serverSrc = buildInfo["serverSrc"];
                var serverOutput = buildInfo["serverOutput"];
                var appSrc = buildInfo["appSrc"];
                var manifestDirs = buildInfo["manifestDirs"];
                if (!(serverEntry &&
                    typeof serverEntry === "string" &&
                    serverOutput &&
                    typeof serverOutput === "string" &&
                    serverSrc &&
                    typeof serverSrc === "string")) {
                    throw Error("Wrong schema of ".concat(exports.buildInfoFilename, "."));
                }
                var manifestPkgs = manifestDirs.map(function (manifestDef) {
                    if (manifestDef["pkg"]) {
                        return path_1.default.dirname(require.resolve("".concat(manifestDef.pkg, "/package.json")));
                    }
                    else {
                        throw Error("Wrong schema of ".concat(exports.buildInfoFilename, "."));
                    }
                });
                var includes = __spreadArray(__spreadArray([], manifestPkgs, true), [appSrc, serverSrc], false);
                var compiler = buildServer({
                    serverEntry: path_1.default.resolve(serverEntry),
                    serverOutput: path_1.default.resolve(serverOutput),
                    includes: includes.map(function (inc) { return path_1.default.resolve(inc); }),
                    mode: mode,
                    allowList: manifestDirs.map(function (dir) { return dir.pkg; }),
                    addWatchOptions: false,
                    serverSideEntry: path_1.default.resolve(serverSideEntry),
                });
                compiler.hooks.done.tap("server built with defaults", function (stats) {
                    res(stats);
                });
            }
            else {
                rej("Missing manifestDirs in ".concat(exports.buildInfoFilename));
            }
        }
        catch (err) {
            rej(err);
        }
    });
}
exports.buildServerWithDefaults = buildServerWithDefaults;
//# sourceMappingURL=utils.js.map