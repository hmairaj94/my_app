"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deploy = void 0;
var fs_extra_1 = __importDefault(require("fs-extra"));
var path_1 = __importDefault(require("path"));
var os_1 = __importDefault(require("os"));
var logger_1 = __importDefault(require("@docusaurus/logger"));
var shelljs_1 = __importDefault(require("shelljs"));
var utils_1 = require("@docusaurus/utils");
var utils_2 = require("../shared/utils");
function obfuscateGitPass(str) {
    var gitPass = process.env["GIT_PASS"];
    return gitPass ? str.replace(gitPass, "GIT_PASS") : str;
}
function shellExecLog(cmd) {
    try {
        var result = shelljs_1.default.exec(cmd);
        logger_1.default.info(templateObject_1 || (templateObject_1 = __makeTemplateObject(["code=", " subdue=", ""], ["code=", " subdue=", ""])), obfuscateGitPass(cmd), "code: ".concat(result.code));
        return result;
    }
    catch (err) {
        logger_1.default.error(templateObject_2 || (templateObject_2 = __makeTemplateObject(["code=", ""], ["code=", ""])), obfuscateGitPass(cmd));
        throw err;
    }
}
function deploy(paths, serverInfo) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    return __awaiter(this, void 0, void 0, function () {
        var sourceRepoUrl, sourceBranch, gitUser, useSSH, serverInfoPath, ssgOutput, organizationName, projectName, isPullRequest, isGitHubPagesOrganizationDeploy, deploymentBranch, githubHost, githubPort, deploymentRepoURL, gitPass, gitCredentials, crossRepoPublish, currentCommit, runDeploy;
        var _this = this;
        return __generator(this, function (_m) {
            logger_1.default.info("Deploy command invoked...");
            if (!shelljs_1.default.which("git")) {
                throw new Error("Git not installed or on the PATH!");
            }
            sourceRepoUrl = shelljs_1.default
                .exec("git config --get remote.origin.url", { silent: true })
                .stdout.trim();
            sourceBranch = (_a = process.env["CURRENT_BRANCH"]) !== null && _a !== void 0 ? _a : shelljs_1.default
                .exec("git rev-parse --abbrev-ref HEAD", { silent: true })
                .stdout.trim();
            gitUser = process.env["GIT_USER"];
            useSSH = process.env["USE_SSH"] !== undefined &&
                process.env["USE_SSH"].toLowerCase() === "true";
            if (!gitUser && !useSSH) {
                // If USE_SSH is unspecified: try inferring from repo URL
                if (process.env["USE_SSH"] === undefined && (0, utils_1.hasSSHProtocol)(sourceRepoUrl)) {
                    useSSH = true;
                }
                else {
                    throw new Error("Please set the GIT_USER environment variable, or explicitly specify USE_SSH instead!");
                }
            }
            serverInfoPath = paths.serverInfo, ssgOutput = paths.ssgOutput;
            organizationName = (_c = (_b = process.env["ORGANIZATION_NAME"]) !== null && _b !== void 0 ? _b : process.env["CIRCLE_PROJECT_USERNAME"]) !== null && _c !== void 0 ? _c : serverInfo.organizationName;
            if (!organizationName) {
                throw new Error("Missing project organization name. Did you forget to define \"organizationName\" in ".concat(serverInfoPath, "? You may also export it via the ORGANIZATION_NAME environment variable."));
            }
            logger_1.default.info(templateObject_3 || (templateObject_3 = __makeTemplateObject(["organizationName: name=", ""], ["organizationName: name=", ""])), organizationName);
            projectName = (_e = (_d = process.env["PROJECT_NAME"]) !== null && _d !== void 0 ? _d : process.env["CIRCLE_PROJECT_REPONAME"]) !== null && _e !== void 0 ? _e : serverInfo.projectName;
            if (!projectName) {
                throw new Error("Missing project name. Did you forget to define \"projectName\" in ".concat(serverInfo, "? You may also export it via the PROJECT_NAME environment variable."));
            }
            isPullRequest = (_f = process.env["CI_PULL_REQUEST"]) !== null && _f !== void 0 ? _f : process.env["CIRCLE_PULL_REQUEST"];
            if (isPullRequest) {
                shelljs_1.default.echo("Skipping deploy on a pull request.");
                shelljs_1.default.exit(0);
            }
            isGitHubPagesOrganizationDeploy = projectName.includes(".github.io");
            if (isGitHubPagesOrganizationDeploy &&
                !process.env["DEPLOYMENT_BRANCH"] &&
                !serverInfo.deploymentBranch) {
                throw new Error("For GitHub pages organization deployments, 'atri publish ssg' does not assume anymore that 'master' is your default Git branch.\nPlease provide the branch name to deploy to as an environment variable, for example DEPLOYMENT_BRANCH=main or DEPLOYMENT_BRANCH=master .\nYou can also set the deploymentBranch property in atri-server-info.json .");
            }
            deploymentBranch = (_h = (_g = process.env["DEPLOYMENT_BRANCH"]) !== null && _g !== void 0 ? _g : serverInfo.deploymentBranch) !== null && _h !== void 0 ? _h : "gh-pages";
            logger_1.default.info(templateObject_4 || (templateObject_4 = __makeTemplateObject(["deploymentBranch: name=", ""], ["deploymentBranch: name=", ""])), deploymentBranch);
            githubHost = (_k = (_j = process.env["GITHUB_HOST"]) !== null && _j !== void 0 ? _j : serverInfo.githubHost) !== null && _k !== void 0 ? _k : "github.com";
            githubPort = (_l = process.env["GITHUB_PORT"]) !== null && _l !== void 0 ? _l : serverInfo.githubPort;
            if (useSSH) {
                deploymentRepoURL = (0, utils_1.buildSshUrl)(githubHost, organizationName, projectName, githubPort);
            }
            else {
                gitPass = process.env["GIT_PASS"];
                gitCredentials = gitPass ? "".concat(gitUser, ":").concat(gitPass) : gitUser;
                deploymentRepoURL = (0, utils_1.buildHttpsUrl)(gitCredentials, githubHost, organizationName, projectName, githubPort);
            }
            logger_1.default.info(templateObject_5 || (templateObject_5 = __makeTemplateObject(["Remote repo URL: name=", ""], ["Remote repo URL: name=", ""])), obfuscateGitPass(deploymentRepoURL));
            crossRepoPublish = !sourceRepoUrl.endsWith("".concat(organizationName, "/").concat(projectName, ".git"));
            // We don't allow deploying to the same branch unless it's a cross publish.
            if (sourceBranch === deploymentBranch && !crossRepoPublish) {
                throw new Error("You cannot deploy from this branch (".concat(sourceBranch, ").") +
                    "\nYou will need to checkout to a different branch!");
            }
            currentCommit = shellExecLog("git rev-parse HEAD").stdout.trim();
            runDeploy = function (outputDirectory) { return __awaiter(_this, void 0, void 0, function () {
                var fromPath, toPath, err_1, commitMessage, commitResults, websiteURL;
                var _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            fromPath = outputDirectory;
                            return [4 /*yield*/, fs_extra_1.default.mkdtemp(path_1.default.join(os_1.default.tmpdir(), "".concat(projectName, "-").concat(deploymentBranch)))];
                        case 1:
                            toPath = _b.sent();
                            shelljs_1.default.cd(toPath);
                            // Check out deployment branch when cloning repository, and then remove all
                            // the files in the directory. If the 'clone' command fails, assume that
                            // the deployment branch doesn't exist, and initialize git in an empty
                            // directory, check out a clean deployment branch and add remote.
                            if (shellExecLog("git clone --depth 1 --branch ".concat(deploymentBranch, " ").concat(deploymentRepoURL, " \"").concat(toPath, "\"")).code === 0) {
                                shellExecLog("git rm -rf .");
                            }
                            else {
                                shellExecLog("git init");
                                shellExecLog("git checkout -b ".concat(deploymentBranch));
                                shellExecLog("git remote add origin ".concat(deploymentRepoURL));
                            }
                            _b.label = 2;
                        case 2:
                            _b.trys.push([2, 4, , 5]);
                            return [4 /*yield*/, fs_extra_1.default.copy(fromPath, toPath)];
                        case 3:
                            _b.sent();
                            return [3 /*break*/, 5];
                        case 4:
                            err_1 = _b.sent();
                            logger_1.default.error(templateObject_6 || (templateObject_6 = __makeTemplateObject(["Copying build assets from path=", " to path=", " failed."], ["Copying build assets from path=", " to path=", " failed."])), fromPath, toPath);
                            throw err_1;
                        case 5:
                            shellExecLog("git add --all");
                            commitMessage = (_a = process.env["CUSTOM_COMMIT_MESSAGE"]) !== null && _a !== void 0 ? _a : "Deploy website - based on ".concat(currentCommit);
                            commitResults = shellExecLog("git commit -m \"".concat(commitMessage, "\""));
                            if (shellExecLog("git push --force origin ".concat(deploymentBranch)).code !== 0) {
                                throw new Error('Running "git push" command failed. Does the GitHub user account you are using have push access to the repository?');
                            }
                            else if (commitResults.code === 0) {
                                websiteURL = "";
                                if (githubHost === "github.com") {
                                    websiteURL = projectName.includes(".github.io")
                                        ? "https://".concat(organizationName, ".github.io/")
                                        : "https://".concat(organizationName, ".github.io/").concat(projectName, "/");
                                }
                                else {
                                    // GitHub enterprise hosting.
                                    websiteURL = "https://".concat(githubHost, "/pages/").concat(organizationName, "/").concat(projectName, "/");
                                }
                                shelljs_1.default.echo("Website is live at \"".concat(websiteURL, "\"."));
                                shelljs_1.default.exit(0);
                            }
                            return [2 /*return*/];
                    }
                });
            }); };
            runDeploy(ssgOutput);
            return [2 /*return*/];
        });
    });
}
exports.deploy = deploy;
var appServerInfo = JSON.parse(fs_extra_1.default.readFileSync("atri-server-info.json").toString());
deploy({
    ssgOutput: utils_2.ssgOutputPath,
    serverInfo: path_1.default.resolve("atri-server-info.json"),
}, appServerInfo);
var templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6;
//# sourceMappingURL=deploy-ssg.js.map