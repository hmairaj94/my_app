import { Fragment as _Fragment, jsx as _jsx } from "react/jsx-runtime";
import { useEffect } from "react";
import { menuRegistry, containerRegistry, tabsRegistry } from "./layerDetails";
var subscribers = { menu: {}, tabs: {}, containers: {} };
/**
 *
 * @param name Pass a local value. The local value must be a string literal as it's replaced with global value during build.
 * @returns
 */
export function menu(name) {
    if (menuRegistry[name] === undefined) {
        console.error("Menu with name ".concat(name, " does not exist.\nMake sure that the menu is registered by a layer in layer.config.js\nOR\nMake sure to remap the layer in tool.confgi.js."));
        return;
    }
    var register = function (item) {
        menuRegistry[name].items.push(item);
        menuRegistry[name].items.sort(function (a, b) {
            return a.order - b.order;
        });
        if (subscribers.menu[name]) {
            subscribers.menu[name].forEach(function (cb) {
                return cb({ nodes: item.nodes, event: "registered" });
            });
        }
    };
    var unregister = function (nodes) {
        var foundIndex = menuRegistry[name].items.findIndex(function (value) { return value.nodes === nodes; });
        if (foundIndex >= 0) {
            menuRegistry[name].items.splice(foundIndex, 1);
            if (subscribers.menu[name]) {
                subscribers.menu[name].forEach(function (cb) {
                    return cb({ nodes: nodes, event: "unregistered" });
                });
            }
        }
    };
    var items = function () {
        return menuRegistry[name].items;
    };
    var listen = function (cb) {
        if (subscribers.menu[name]) {
            subscribers.menu[name].push(cb);
        }
        else {
            subscribers.menu[name] = [cb];
        }
        return {
            unsubscribe: function () {
                var foundIndex = subscribers.menu[name].findIndex(function (value) {
                    return value === cb;
                });
                if (foundIndex >= 0) {
                    subscribers.menu[name].splice(foundIndex, 1);
                }
            },
            items: menuRegistry[name].items,
        };
    };
    return { register: register, listen: listen, items: items, unregister: unregister };
}
/**
 *
 * @param name Pass a local value. The local value must be a string literal as it's replaced with global value during build.
 * @returns
 */
export function container(name) {
    if (containerRegistry[name] === undefined) {
        console.error("Container with name ".concat(name, " does not exist.\nMake sure that the container is registered by a layer in layer.config.js\nOR\nMake sure to remap the layer in tool.confgi.js."));
        return;
    }
    var register = function (item) {
        // close previous container item
        containerRegistry[name].items.forEach(function (item) { return item.onClose(); });
        // Containers won't remember the history of items they have rendered till now.
        // Hence, replacing all the contents of items with just one new item.
        containerRegistry[name].items = [item];
        if (subscribers.containers[name]) {
            subscribers.containers[name].forEach(function (cb) {
                return cb({ node: item.node, event: "registered" });
            });
        }
    };
    var unregister = function (node) {
        var foundIndex = containerRegistry[name].items.findIndex(function (value) { return value.node === node; });
        if (foundIndex >= 0) {
            containerRegistry[name].items.splice(foundIndex, 1);
            if (subscribers.containers[name]) {
                subscribers.containers[name].forEach(function (cb) {
                    return cb({ node: node, event: "unregistered" });
                });
            }
        }
    };
    var pop = function () {
        var item = containerRegistry[name].items.pop();
        if (subscribers.containers[name] && item) {
            subscribers.containers[name].forEach(function (cb) {
                return cb({ node: item.node, event: "unregistered" });
            });
        }
    };
    var items = function () {
        return containerRegistry[name].items;
    };
    var listen = function (cb) {
        if (subscribers.containers[name]) {
            subscribers.containers[name].push(cb);
        }
        else {
            subscribers.containers[name] = [cb];
        }
        return {
            unsubscribe: function () {
                var foundIndex = subscribers.containers[name].findIndex(function (value) {
                    return value === cb;
                });
                if (foundIndex >= 0) {
                    subscribers.containers[name].splice(foundIndex, 1);
                }
            },
            items: containerRegistry[name].items,
        };
    };
    return { register: register, listen: listen, items: items, unregister: unregister, pop: pop };
}
/**
 *
 * @param name Pass a local value. The local value must be a string literal as it's replaced with global value during build.
 * @returns
 */
export function tab(name) {
    if (tabsRegistry[name] === undefined) {
        console.error("Tab bar with name ".concat(name, " does not exist.\nMake sure that the tab bar is registered by a layer in layer.config.js\nOR\nMake sure to remap the layer in tool.confgi.js."));
        return;
    }
    var register = function (item) {
        tabsRegistry[name].items.push(item);
        if (subscribers.tabs[name]) {
            subscribers.tabs[name].forEach(function (cb) { return cb({ item: item, event: "registered" }); });
        }
    };
    var unregister = function (item) {
        var foundIndex = tabsRegistry[name].items.findIndex(function (value) { return value === item; });
        if (foundIndex >= 0) {
            tabsRegistry[name].items.splice(foundIndex, 1);
            if (subscribers.tabs[name]) {
                subscribers.tabs[name].forEach(function (cb) {
                    return cb({ item: item, event: "unregistered" });
                });
            }
        }
    };
    var items = function () {
        return tabsRegistry[name].items;
    };
    var listen = function (cb) {
        if (subscribers.tabs[name]) {
            subscribers.tabs[name].push(cb);
        }
        else {
            subscribers.tabs[name] = [cb];
        }
        return {
            unsubscribe: function () {
                var foundIndex = subscribers.tabs[name].findIndex(function (value) {
                    return value === cb;
                });
                if (foundIndex >= 0) {
                    subscribers.tabs[name].splice(foundIndex, 1);
                }
            },
            items: tabsRegistry[name].items,
        };
    };
    return { register: register, listen: listen, items: items, unregister: unregister };
}
export var Container = function (props) {
    useEffect(function () {
        var namedContainer = container(props.name);
        if (Array.isArray(props.children)) {
            props.children.forEach(function (child) {
                namedContainer === null || namedContainer === void 0 ? void 0 : namedContainer.register({ node: child, onClose: props.onClose });
            });
        }
        else {
            namedContainer === null || namedContainer === void 0 ? void 0 : namedContainer.register({
                node: props.children,
                onClose: props.onClose,
            });
        }
        return function () {
            if (Array.isArray(props.children)) {
                props.children.forEach(function (child) {
                    namedContainer === null || namedContainer === void 0 ? void 0 : namedContainer.unregister(child);
                });
            }
            else {
                namedContainer === null || namedContainer === void 0 ? void 0 : namedContainer.unregister(props.children);
            }
        };
    }, [props]);
    return _jsx(_Fragment, {});
};
export var Menu = function (props) {
    useEffect(function () {
        var namedMenu = menu(props.name);
        if (Array.isArray(props.children)) {
            props.children.forEach(function (child) {
                namedMenu === null || namedMenu === void 0 ? void 0 : namedMenu.register({ nodes: child, order: props.order });
            });
        }
        else {
            namedMenu === null || namedMenu === void 0 ? void 0 : namedMenu.register({ nodes: props.children, order: props.order });
        }
        return function () {
            if (Array.isArray(props.children)) {
                props.children.forEach(function (child) {
                    namedMenu === null || namedMenu === void 0 ? void 0 : namedMenu.unregister(child);
                });
            }
            else {
                namedMenu === null || namedMenu === void 0 ? void 0 : namedMenu.unregister(props.children);
            }
        };
    }, [props]);
    return _jsx(_Fragment, {});
};
export var Tab = function (props) {
    useEffect(function () {
        var namedTab = tab(props.name);
        namedTab === null || namedTab === void 0 ? void 0 : namedTab.register(props);
        return function () {
            namedTab === null || namedTab === void 0 ? void 0 : namedTab.unregister(props);
        };
    }, [props]);
    return _jsx(_Fragment, {});
};
var refRegistry = {};
export function attachRef(name, ref) {
    refRegistry[name] = ref;
}
/**
 *
 * detachRef deletes a ref from registry only if the provided ref matches the existing ref.
 * If it doesn't matches, then it does nothing.
 */
export function detachRef(name, ref) {
    if (refRegistry[name] && refRegistry[name] === ref) {
        delete refRegistry[name];
    }
}
export function getRef(name) {
    return refRegistry[name];
}
//# sourceMappingURL=layerSockets.js.map