import { ReactNode } from "react";
import { AnyEvent, Folder, Page, PageDetails } from "@atrilabs/forest";
import { Socket } from "socket.io-client";
/**
 * NOTE: A layer entry function must return Container, Menu, Tab
 * or a React.Fragment with Container, Menu, Tab.
 *
 * A runtime entry function must take layers as children.
 * The runtime entry function must manage the layers as deemed fit.
 */
export declare type MenuItem = {
    nodes: ReactNode | ReactNode[];
    order: number;
};
export declare type ContainerItem = {
    node: ReactNode | ReactNode[];
    onClose: () => void;
};
export declare type TabItem = {
    header: ReactNode;
    body: ReactNode;
    itemName: string;
};
/**
 * map of a name local to a layer with it's global name
 */
export declare type NameMap = {
    [localName: string]: string;
};
export declare type LayerConfig = {
    modulePath: string;
    requires: Partial<{
        menu: NameMap;
        containers: NameMap;
        tabs: NameMap;
    }>;
    exposes: Partial<{
        menu: NameMap;
        containers: NameMap;
        tabs: NameMap;
    }>;
    runtime?: {
        pkg: string;
    };
    manifestSchema?: {
        pkg: string;
    }[];
};
export declare type RuntimeConfig = {
    modulePath: string;
    requires: Partial<{
        menu: NameMap;
        containers: NameMap;
        tabs: NameMap;
    }>;
    exposes: Partial<{
        menu: NameMap;
        containers: NameMap;
        tabs: NameMap;
    }>;
    manifestSchema?: {
        pkg: string;
    }[];
};
export declare type ForestsConfig = {
    [forestPkg: string]: {
        modulePath: string;
    }[];
};
export declare type ToolConfig = {
    pkgManager: "npm" | "yarn";
    forests: ForestsConfig;
    forestManager: {
        path: string;
        options: any;
    };
    layers: {
        pkg: string;
        remap?: Partial<{
            requires: LayerConfig["requires"];
            exposes: LayerConfig["exposes"];
        }>;
    }[];
    /**
     * directory where editor code will be emitted.
     * web    - contains ui of editor
     * server - contains backend of editor
     */
    output: string;
    /**
     * All the services must export a default function
     * The args for the function will be -
     * 1. ToolConfig - default export from tool.config.json file
     * 2. options - custom options
     */
    services: {
        fileServer: {
            path: string;
            options: any;
        };
        eventServer: {
            path: string;
            options: any;
        };
        manifestServer: {
            path: string;
            options: any;
        };
        publishServer: {
            path: string;
            options: any;
        };
        ipcServer: {
            path: string;
            options: any;
        };
    };
    targets: {
        targetName: string;
        hint: string;
        description: string;
        tasksHandler: {
            modulePath: string;
        };
        options: any;
    }[];
    /**
     * All the clients must default export their API.
     */
    clients: {
        /**
         * The eventClient is counterpart of eventServer that gets bundled in the core package.
         * Please use env field to pass on options to the client like host & port.
         * modulePath must resolve to the client module when used with require.resolve.
         */
        eventClient: {
            modulePath: string;
        };
    };
    /**
     * env is generally used to supply port to clients for their
     * respective servers.
     */
    env: {
        [key: string]: number | string | boolean;
    };
    runtimes: {
        pkg: string;
        remap?: Partial<{
            requires: RuntimeConfig["requires"];
            exposes: RuntimeConfig["exposes"];
        }>;
    }[];
    /**
     * This client will be embedded into the codebase.
     * This client will be responsible to manage manifestRegistry
     * by communicating with manifestServer
     */
    manifestClient: {
        path: string;
        devPath: string;
    };
    manifestSchema: {
        pkg: string;
    }[];
    manifestDirs: {
        pkg: string;
    }[];
    devServerProxy: {
        hostname: string;
    };
    assetManager: {
        urlPath: string;
        assetsDir: string;
    };
    templateManager: {
        defaultDirs?: string[];
        dirs?: string[];
    };
    resources: {
        path: string;
    };
};
export declare type ManifestSchemaConfig = {
    modulePath: string;
    libs: "react"[];
};
export declare type ManifestSchema = {
    validate: (manifest: any) => boolean;
};
export declare type ManifestConfig = {
    dir: string;
    manifestSchema: {
        pkg: string;
    }[];
    componentMap: {
        [key: string]: {
            modulePath: string;
            exportedVarName: string;
        };
    };
};
export declare type ManifestRegistry = {
    [manifestId: string]: {
        schema: ManifestSchema;
        components: {
            pkg: string;
            component: any;
        }[];
    };
};
export declare type EventSubscriber = (forestPkgId: string, pageId: string, event: AnyEvent) => void;
export declare type TemplateDetail = {
    relativeDir: string;
    templateName: string;
};
export declare type ImportedResource = {
    str: string;
    method: "link" | "css";
    imports: {
        fonts?: {
            fontFamily: string;
            fontWeight: string | number;
            fontStyle: string;
        }[];
    };
};
export declare type BrowserClient = {
    getSocket(): Socket;
    getIPCSocket(): Socket;
    getMeta(forestPkgId: string, onData: (meta: any) => void): void;
    getPages(forestPkgId: string, onData: (pages: {
        [pageId: string]: PageDetails;
    }) => void): void;
    createFolder(forestPkgId: string, folder: Folder, callback: (success: boolean) => void): void;
    updateFolder(forestPkgId: string, id: string, update: Partial<Omit<Folder, "id">>, callback: (success: boolean) => void): void;
    createPage(forestPkgId: string, page: Page, callback: (success: boolean) => void): void;
    updatePage(forestPkgId: string, id: string, update: Partial<Omit<Page, "id">>, callback: (success: boolean) => void): void;
    deletePage(forestPkgId: string, id: string, callback: (success: boolean) => void): void;
    deleteFolder(forestPkgId: string, id: string, callback: (success: boolean) => void): void;
    fetchEvents(forestPkgId: string, pageId: string): Promise<AnyEvent[]>;
    postNewEvent(forestPkgId: string, pageId: string, event: AnyEvent, callback: (success: boolean) => void): void;
    getNewAlias(forestPkgId: string, prefix: string, callback: (alias: string) => void): void;
    subscribeEvents(cb: EventSubscriber): () => void;
    subscribeExternalEvents(cb: EventSubscriber): () => void;
    subscribeOwnEvents(cb: EventSubscriber): () => void;
    /**
     *
     * @param files Each property of file is derived from the Web API File.
     */
    uploadAssets(files: {
        name: string;
        data: ArrayBuffer;
        size: number;
        mime: string;
    }[], callback: (success: boolean, urls: string[]) => void): void;
    getAssetsInfo: (callback: (assets: {
        [name: string]: {
            url: string;
            mime: string;
        };
    }) => void) => void;
    /** template management api */
    getTemplateList: (callback: (details: TemplateDetail[]) => void) => void;
    createTemplate: (dir: string, name: string, events: AnyEvent[], callback: (success: boolean) => void) => void;
    overwriteTemplate: (dir: string, name: string, events: AnyEvent[], callback: (success: boolean) => void) => void;
    deleteTemplate: (dir: string, name: string, callback: (success: boolean) => void) => void;
    getTemplateEvents: (dir: string, name: string, callback: (events: AnyEvent[]) => void) => void;
    /** resource management api */
    importResource: (importStatement: {
        str: string;
    }, callback: (success: boolean) => void) => void;
    getResources: (callback: (resources: ImportedResource[]) => void) => void;
    subscribeResourceUpdates: (callback: (resource: ImportedResource) => void) => void;
    getAttachedServicesStatus: (callback: (status: {
        [clientName: string]: boolean;
    }) => void) => void;
    subscribeServiceStatus: (callback: (status: {
        [clientName: string]: boolean;
    }) => void) => () => void;
};
export declare type Script = {
    src: string;
    scriptName: string;
};
export declare type ManifestPkg = {
    pkg: string;
};
export declare type ManifestPkgBundle = ManifestPkg & Script;
export declare type Cache = {
    [pkg: string]: {
        files: {
            [filepath: string]: {
                timestamp: Date;
            };
        };
        freeze?: boolean;
    };
};
export declare type ServerInfo = {
    port: number;
    pythonPort: number;
    publicDir: string;
    pages: {
        [key: string]: any;
    };
    publicUrlAssetMap: {
        [url: string]: string;
    };
    controllerHost?: string;
    organizationName?: string;
    projectName?: string;
    deploymentBranch?: string;
    githubHost?: string;
    githubPort?: string;
    static?: string;
};
export declare type AppInfo = {
    prefixUrl: string;
};
export declare type BuildInfo = {
    appSrc: string;
    appEntry: string;
    appHtml: string;
    appOutput: string;
    serverSrc: string;
    serverEntry: string;
    serverSideEntry: string;
    serverOutput: string;
    manifestDirs: string[];
    assetUrlPrefix: string;
};
export declare type Portals = {
    node: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
    selector: string;
}[];
//# sourceMappingURL=types.d.ts.map